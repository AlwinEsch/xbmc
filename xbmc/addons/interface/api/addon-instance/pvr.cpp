/*
 *  Copyright (C) 2005-2021 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "pvr.h"

// Shared API
#include "addons/kodi-dev-kit/src/shared/api/addon-instance/pvr.h"

// Kodi
#include "addons/interface/RunningProcess.h"
#include "pvr/addons/PVRClient.h"
#include "utils/log.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

namespace KODI
{
namespace ADDONS
{
namespace INTERFACE
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_addoninstance_pvr_h::InitDirect(directFuncToKodi_addoninstance_pvr_h* ifcToKodi,
                                               directFuncToAddon_addoninstance_pvr_h* ifcToAddon)
{
  ifcToKodi->thisClassHdl = this;
  m_ifcToAddon = ifcToAddon;
  ifcToKodi->kodi_addon_pvr_get_epg_max_future_days_v1 = kodi_addon_pvr_get_epg_max_future_days_v1;
  ifcToKodi->kodi_addon_pvr_get_epg_max_past_days_v1 = kodi_addon_pvr_get_epg_max_past_days_v1;
  ifcToKodi->kodi_addon_pvr_add_menu_hook_v1 = kodi_addon_pvr_add_menu_hook_v1;
  ifcToKodi->kodi_addon_pvr_recording_notification_v1 = kodi_addon_pvr_recording_notification_v1;
  ifcToKodi->kodi_addon_pvr_connection_state_change_v1 = kodi_addon_pvr_connection_state_change_v1;
  ifcToKodi->kodi_addon_pvr_epg_event_state_change_v1 = kodi_addon_pvr_epg_event_state_change_v1;
  ifcToKodi->kodi_addon_pvr_transfer_channel_entry_v1 = kodi_addon_pvr_transfer_channel_entry_v1;
  ifcToKodi->kodi_addon_pvr_transfer_channel_group_v1 = kodi_addon_pvr_transfer_channel_group_v1;
  ifcToKodi->kodi_addon_pvr_transfer_channel_group_member_v1 =
      kodi_addon_pvr_transfer_channel_group_member_v1;
  ifcToKodi->kodi_addon_pvr_transfer_epg_entry_v1 = kodi_addon_pvr_transfer_epg_entry_v1;
  ifcToKodi->kodi_addon_pvr_transfer_recording_entry_v1 =
      kodi_addon_pvr_transfer_recording_entry_v1;
  ifcToKodi->kodi_addon_pvr_transfer_timer_entry_v1 = kodi_addon_pvr_transfer_timer_entry_v1;
  ifcToKodi->kodi_addon_pvr_trigger_channel_update_v1 = kodi_addon_pvr_trigger_channel_update_v1;
  ifcToKodi->kodi_addon_pvr_trigger_channel_groups_update_v1 =
      kodi_addon_pvr_trigger_channel_groups_update_v1;
  ifcToKodi->kodi_addon_pvr_trigger_epg_update_v1 = kodi_addon_pvr_trigger_epg_update_v1;
  ifcToKodi->kodi_addon_pvr_trigger_recording_update_v1 =
      kodi_addon_pvr_trigger_recording_update_v1;
  ifcToKodi->kodi_addon_pvr_trigger_timer_update_v1 = kodi_addon_pvr_trigger_timer_update_v1;
}

bool CHdl_kodi_addoninstance_pvr_h::HandleMessage(int funcGroup,
                                                  int func,
                                                  const msgpack::unpacked& in,
                                                  msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_addoninstance_pvr_h)
    return false;

  switch (func)
  {
    case funcParent_kodi_addon_pvr_get_epg_max_future_days_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int kodi_addon_pvr_get_epg_max_future_days(KODI_OWN_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_pvr_get_epg_max_future_days_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_addon_pvr_get_epg_max_future_days_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_get_epg_max_future_days_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      int auto_gen_ret = kodi_addon_pvr_get_epg_max_future_days_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_addon_pvr_get_epg_max_future_days_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_pvr_get_epg_max_past_days_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int kodi_addon_pvr_get_epg_max_past_days(KODI_OWN_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_pvr_get_epg_max_past_days_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_addon_pvr_get_epg_max_past_days_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_get_epg_max_past_days_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      int auto_gen_ret = kodi_addon_pvr_get_epg_max_past_days_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_addon_pvr_get_epg_max_past_days_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_addon_pvr_add_menu_hook_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_add_menu_hook(KODI_OWN_HDL hdl, const struct PVR_MENUHOOK* hook) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_MENUHOOK> msgParent__IN_kodi_addon_pvr_add_menu_hook_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_add_menu_hook_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_add_menu_hook_v1 t = in.get().as<decltype(t)>();
      PVR_MENUHOOK hook;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      std::get<1>(t).SetCStructure(&hook);
      kodi_addon_pvr_add_menu_hook_v1(this, hdl, &hook);
      return true;
    }
    case funcParent_kodi_addon_pvr_recording_notification_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_recording_notification(KODI_OWN_HDL hdl, const char* name, const char* fileName, bool on) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, std::string, bool> msgParent__IN_kodi_addon_pvr_recording_notification_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_recording_notification_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_recording_notification_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      const std::string& fileName = std::get<2>(t);
      bool on = std::get<3>(t);
      kodi_addon_pvr_recording_notification_v1(this, hdl, name.c_str(), fileName.c_str(), on);
      return true;
    }
    case funcParent_kodi_addon_pvr_connection_state_change_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_connection_state_change(KODI_OWN_HDL hdl, const char* strConnectionString, enum PVR_CONNECTION_STATE newState, const char* strMessage) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, PVR_CONNECTION_STATE, std::string> msgParent__IN_kodi_addon_pvr_connection_state_change_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_connection_state_change_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_connection_state_change_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const std::string& strConnectionString = std::get<1>(t);
      enum PVR_CONNECTION_STATE newState = std::get<2>(t);
      const std::string& strMessage = std::get<3>(t);
      kodi_addon_pvr_connection_state_change_v1(this, hdl, strConnectionString.c_str(), newState,
                                                strMessage.c_str());
      return true;
    }
    case funcParent_kodi_addon_pvr_epg_event_state_change_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_epg_event_state_change(KODI_OWN_HDL hdl, struct EPG_TAG* tag, enum EPG_EVENT_STATE newState) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, EPG_EVENT_STATE> msgParent__IN_kodi_addon_pvr_epg_event_state_change_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<IFC_EPG_TAG> msgParent_OUT_kodi_addon_pvr_epg_event_state_change_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_epg_event_state_change_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      struct EPG_TAG tag;
      enum EPG_EVENT_STATE newState = std::get<1>(t);
      kodi_addon_pvr_epg_event_state_change_v1(this, hdl, &tag, newState);
      msgpack::pack(out, msgParent_OUT_kodi_addon_pvr_epg_event_state_change_v1(&tag));
      return true;
    }
    case funcParent_kodi_addon_pvr_transfer_channel_entry_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_transfer_channel_entry( KODI_OWN_HDL hdl, const KODI_ADDON_PVR_TRANSFER_HDL handle, const struct PVR_CHANNEL* chan) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_PVR_CHANNEL> msgParent__IN_kodi_addon_pvr_transfer_channel_entry_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_transfer_channel_entry_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_transfer_channel_entry_v1 t = in.get().as<decltype(t)>();
      PVR_CHANNEL chan;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const KODI_ADDON_PVR_TRANSFER_HDL handle =
          reinterpret_cast<const KODI_ADDON_PVR_TRANSFER_HDL>(std::get<1>(t));
      std::get<2>(t).SetCStructure(&chan);
      kodi_addon_pvr_transfer_channel_entry_v1(this, hdl, handle, &chan);
      return true;
    }
    case funcParent_kodi_addon_pvr_transfer_channel_group_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_transfer_channel_group( KODI_OWN_HDL hdl, const KODI_ADDON_PVR_TRANSFER_HDL handle, const struct PVR_CHANNEL_GROUP* group) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_PVR_CHANNEL_GROUP> msgParent__IN_kodi_addon_pvr_transfer_channel_group_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_transfer_channel_group_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_transfer_channel_group_v1 t = in.get().as<decltype(t)>();
      PVR_CHANNEL_GROUP group;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const KODI_ADDON_PVR_TRANSFER_HDL handle =
          reinterpret_cast<const KODI_ADDON_PVR_TRANSFER_HDL>(std::get<1>(t));
      std::get<2>(t).SetCStructure(&group);
      kodi_addon_pvr_transfer_channel_group_v1(this, hdl, handle, &group);
      return true;
    }
    case funcParent_kodi_addon_pvr_transfer_channel_group_member_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_transfer_channel_group_member( KODI_OWN_HDL hdl, const KODI_ADDON_PVR_TRANSFER_HDL handle, const struct PVR_CHANNEL_GROUP_MEMBER* member) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_PVR_CHANNEL_GROUP_MEMBER> msgParent__IN_kodi_addon_pvr_transfer_channel_group_member_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_transfer_channel_group_member_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_transfer_channel_group_member_v1 t = in.get().as<decltype(t)>();
      PVR_CHANNEL_GROUP_MEMBER member;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const KODI_ADDON_PVR_TRANSFER_HDL handle =
          reinterpret_cast<const KODI_ADDON_PVR_TRANSFER_HDL>(std::get<1>(t));
      std::get<2>(t).SetCStructure(&member);
      kodi_addon_pvr_transfer_channel_group_member_v1(this, hdl, handle, &member);
      return true;
    }
    case funcParent_kodi_addon_pvr_transfer_epg_entry_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_transfer_epg_entry(KODI_OWN_HDL hdl, const KODI_ADDON_PVR_TRANSFER_HDL handle, const struct EPG_TAG* epgentry) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_EPG_TAG> msgParent__IN_kodi_addon_pvr_transfer_epg_entry_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_transfer_epg_entry_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_transfer_epg_entry_v1 t = in.get().as<decltype(t)>();
      EPG_TAG epgentry;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const KODI_ADDON_PVR_TRANSFER_HDL handle =
          reinterpret_cast<const KODI_ADDON_PVR_TRANSFER_HDL>(std::get<1>(t));
      std::get<2>(t).SetCStructure(&epgentry);
      kodi_addon_pvr_transfer_epg_entry_v1(this, hdl, handle, &epgentry);
      return true;
    }
    case funcParent_kodi_addon_pvr_transfer_recording_entry_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_transfer_recording_entry( KODI_OWN_HDL hdl, const KODI_ADDON_PVR_TRANSFER_HDL handle, const struct PVR_RECORDING* recording) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_PVR_RECORDING> msgParent__IN_kodi_addon_pvr_transfer_recording_entry_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_transfer_recording_entry_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_transfer_recording_entry_v1 t = in.get().as<decltype(t)>();
      PVR_RECORDING recording;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const KODI_ADDON_PVR_TRANSFER_HDL handle =
          reinterpret_cast<const KODI_ADDON_PVR_TRANSFER_HDL>(std::get<1>(t));
      std::get<2>(t).SetCStructure(&recording);
      kodi_addon_pvr_transfer_recording_entry_v1(this, hdl, handle, &recording);
      return true;
    }
    case funcParent_kodi_addon_pvr_transfer_timer_entry_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_transfer_timer_entry(KODI_OWN_HDL hdl, const KODI_ADDON_PVR_TRANSFER_HDL handle, const struct PVR_TIMER* timer) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_PVR_TIMER> msgParent__IN_kodi_addon_pvr_transfer_timer_entry_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_transfer_timer_entry_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_transfer_timer_entry_v1 t = in.get().as<decltype(t)>();
      PVR_TIMER timer;
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      const KODI_ADDON_PVR_TRANSFER_HDL handle =
          reinterpret_cast<const KODI_ADDON_PVR_TRANSFER_HDL>(std::get<1>(t));
      std::get<2>(t).SetCStructure(&timer);
      kodi_addon_pvr_transfer_timer_entry_v1(this, hdl, handle, &timer);
      return true;
    }
    case funcParent_kodi_addon_pvr_trigger_channel_update_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_trigger_channel_update(KODI_OWN_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_pvr_trigger_channel_update_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_trigger_channel_update_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_trigger_channel_update_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      kodi_addon_pvr_trigger_channel_update_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_addon_pvr_trigger_channel_groups_update_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_trigger_channel_groups_update(KODI_OWN_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_pvr_trigger_channel_groups_update_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_trigger_channel_groups_update_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_trigger_channel_groups_update_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      kodi_addon_pvr_trigger_channel_groups_update_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_addon_pvr_trigger_epg_update_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_trigger_epg_update(KODI_OWN_HDL hdl, unsigned int iChannelUid) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, unsigned int> msgParent__IN_kodi_addon_pvr_trigger_epg_update_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_trigger_epg_update_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_trigger_epg_update_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      unsigned int iChannelUid = std::get<1>(t);
      kodi_addon_pvr_trigger_epg_update_v1(this, hdl, iChannelUid);
      return true;
    }
    case funcParent_kodi_addon_pvr_trigger_recording_update_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_trigger_recording_update(KODI_OWN_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_pvr_trigger_recording_update_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_trigger_recording_update_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_trigger_recording_update_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      kodi_addon_pvr_trigger_recording_update_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_addon_pvr_trigger_timer_update_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_addon_pvr_trigger_timer_update(KODI_OWN_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_addon_pvr_trigger_timer_update_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_addon_pvr_trigger_timer_update_v1; /* Autogenerated */
      msgParent__IN_kodi_addon_pvr_trigger_timer_update_v1 t = in.get().as<decltype(t)>();
      KODI_OWN_HDL hdl = reinterpret_cast<KODI_OWN_HDL>(std::get<0>(t));
      kodi_addon_pvr_trigger_timer_update_v1(this, hdl);
      return true;
    }
    default:
      CLog::Log(LOGERROR,
                "CHdl_kodi_addoninstance_pvr_h::{}: addon called with unknown function id '{}' on "
                "group 'addoninstance_pvr_h'",
                __func__, func);
  }

  return false;
}

// Function calls from Kodi to addon

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_capabilities_v1(
    KODI_ADDON_PVR_HDL hdl, struct PVR_ADDON_CAPABILITIES* capabilities)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CAPABILITIES_V1)( KODI_ADDON_PVR_HDL hdl, struct PVR_ADDON_CAPABILITIES* capabilities);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_get_capabilities_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, IFC_PVR_ADDON_CAPABILITIES> msgChild_OUT_kodi_addon_pvr_get_capabilities_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_capabilities_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_capabilities_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_capabilities_v1 t = ident.get().as<decltype(t)>();
    std::get<1>(t).SetCStructure(capabilities);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_capabilities_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                          capabilities);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_backend_name_v1(
    KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_BACKEND_NAME_V1)( KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size);
  // Tuple in:          typedef std::tuple<PtrValue, size_t> msgChild__IN_kodi_addon_pvr_get_backend_name_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::string> msgChild_OUT_kodi_addon_pvr_get_backend_name_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_backend_name_v1(PtrValue(hdl), mem_size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_backend_name_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_backend_name_v1 t = ident.get().as<decltype(t)>();
    strncpy(str, std::get<1>(t).c_str(), mem_size);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_backend_name_v1(m_ifcToAddon->thisClassHdl, hdl, str,
                                                          mem_size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_backend_version_v1(
    KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_BACKEND_VERSION_V1)( KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size);
  // Tuple in:          typedef std::tuple<PtrValue, size_t> msgChild__IN_kodi_addon_pvr_get_backend_version_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::string> msgChild_OUT_kodi_addon_pvr_get_backend_version_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_backend_version_v1(PtrValue(hdl), mem_size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_backend_version_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_backend_version_v1 t = ident.get().as<decltype(t)>();
    strncpy(str, std::get<1>(t).c_str(), mem_size);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_backend_version_v1(m_ifcToAddon->thisClassHdl, hdl, str,
                                                             mem_size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_backend_hostname_v1(
    KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_BACKEND_HOSTNAME_V1)( KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size);
  // Tuple in:          typedef std::tuple<PtrValue, size_t> msgChild__IN_kodi_addon_pvr_get_backend_hostname_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::string> msgChild_OUT_kodi_addon_pvr_get_backend_hostname_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_backend_hostname_v1(PtrValue(hdl), mem_size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_backend_hostname_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_backend_hostname_v1 t = ident.get().as<decltype(t)>();
    strncpy(str, std::get<1>(t).c_str(), mem_size);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_backend_hostname_v1(m_ifcToAddon->thisClassHdl, hdl, str,
                                                              mem_size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_connection_string_v1(
    KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CONNECTION_STRING_V1)( KODI_ADDON_PVR_HDL hdl, char* str, size_t mem_size);
  // Tuple in:          typedef std::tuple<PtrValue, size_t> msgChild__IN_kodi_addon_pvr_get_connection_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::string> msgChild_OUT_kodi_addon_pvr_get_connection_string_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_get_connection_string_v1(PtrValue(hdl), mem_size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_connection_string_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_connection_string_v1 t = ident.get().as<decltype(t)>();
    strncpy(str, std::get<1>(t).c_str(), mem_size);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_connection_string_v1(m_ifcToAddon->thisClassHdl, hdl, str,
                                                               mem_size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_drive_space_v1(
    KODI_ADDON_PVR_HDL hdl, uint64_t* total, uint64_t* used)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_DRIVE_SPACE_V1)( KODI_ADDON_PVR_HDL hdl, uint64_t* total, uint64_t* used);
  // Tuple in:          typedef std::tuple<PtrValue, uint64_t, uint64_t> msgChild__IN_kodi_addon_pvr_get_drive_space_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, uint64_t, uint64_t> msgChild_OUT_kodi_addon_pvr_get_drive_space_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_drive_space_v1(PtrValue(hdl), *total, *used));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_drive_space_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_drive_space_v1 t = ident.get().as<decltype(t)>();
    *total = std::get<1>(t);
    *used = std::get<2>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_drive_space_v1(m_ifcToAddon->thisClassHdl, hdl, total,
                                                         used);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_call_settings_menu_hook_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_CALL_SETTINGS_MENU_HOOK_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_MENUHOOK> msgChild__IN_kodi_addon_pvr_call_settings_menu_hook_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_call_settings_menu_hook_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_call_settings_menu_hook_v1(PtrValue(hdl), menuhook));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_call_settings_menu_hook_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_call_settings_menu_hook_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_call_settings_menu_hook_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                 menuhook);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_channels_amount_v1(
    KODI_ADDON_PVR_HDL hdl, int* amount)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CHANNELS_AMOUNT_V1)( KODI_ADDON_PVR_HDL hdl, int* amount);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_get_channels_amount_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, int> msgChild_OUT_kodi_addon_pvr_get_channels_amount_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_channels_amount_v1(PtrValue(hdl), *amount));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_channels_amount_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_channels_amount_v1 t = ident.get().as<decltype(t)>();
    *amount = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_channels_amount_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                             amount);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_channels_v1(
    KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, bool radio)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CHANNELS_V1)( KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, bool radio);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, bool> msgChild__IN_kodi_addon_pvr_get_channels_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_get_channels_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_get_channels_v1(PtrValue(hdl), PtrValue(handle), radio));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_channels_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_channels_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_channels_v1(m_ifcToAddon->thisClassHdl, hdl, handle,
                                                      radio);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_channel_stream_properties_v1(
    KODI_ADDON_PVR_HDL hdl,
    const struct PVR_CHANNEL* channel,
    struct PVR_NAMED_VALUE* properties,
    size_t* properties_count)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CHANNEL_STREAM_PROPERTIES_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel, struct PVR_NAMED_VALUE* properties, size_t* properties_count);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_CHANNEL, size_t> msgChild__IN_kodi_addon_pvr_get_channel_stream_properties_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, IFC_PVR_NAMED_VALUE, size_t> msgChild_OUT_kodi_addon_pvr_get_channel_stream_properties_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_channel_stream_properties_v1(
                          PtrValue(hdl), channel, *properties_count));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_channel_stream_properties_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_channel_stream_properties_v1 t = ident.get().as<decltype(t)>();
    std::get<1>(t).SetCStructure(properties);
    *properties_count = std::get<2>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_channel_stream_properties_v1(
      m_ifcToAddon->thisClassHdl, hdl, channel, properties, properties_count);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_signal_status_v1(
    KODI_ADDON_PVR_HDL hdl, int channel_uid, struct PVR_SIGNAL_STATUS* signal_status)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_SIGNAL_STATUS_V1)( KODI_ADDON_PVR_HDL hdl, int channel_uid, struct PVR_SIGNAL_STATUS* signal_status);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_get_signal_status_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, IFC_PVR_SIGNAL_STATUS> msgChild_OUT_kodi_addon_pvr_get_signal_status_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_signal_status_v1(PtrValue(hdl), channel_uid));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_signal_status_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_signal_status_v1 t = ident.get().as<decltype(t)>();
    std::get<1>(t).SetCStructure(signal_status);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_signal_status_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                           channel_uid, signal_status);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_descramble_info_v1(
    KODI_ADDON_PVR_HDL hdl, int channel_uid, struct PVR_DESCRAMBLE_INFO* descramble_info)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_DESCRAMBLE_INFO_V1)( KODI_ADDON_PVR_HDL hdl, int channel_uid, struct PVR_DESCRAMBLE_INFO* descramble_info);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_get_descramble_info_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, IFC_PVR_DESCRAMBLE_INFO> msgChild_OUT_kodi_addon_pvr_get_descramble_info_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_get_descramble_info_v1(PtrValue(hdl), channel_uid));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_descramble_info_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_descramble_info_v1 t = ident.get().as<decltype(t)>();
    std::get<1>(t).SetCStructure(descramble_info);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_descramble_info_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                             channel_uid, descramble_info);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_channel_groups_amount_v1(
    KODI_ADDON_PVR_HDL hdl, int* amount)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CHANNEL_GROUPS_AMOUNT_V1)( KODI_ADDON_PVR_HDL hdl, int* amount);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_get_channel_groups_amount_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, int> msgChild_OUT_kodi_addon_pvr_get_channel_groups_amount_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_get_channel_groups_amount_v1(PtrValue(hdl), *amount));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_channel_groups_amount_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_channel_groups_amount_v1 t = ident.get().as<decltype(t)>();
    *amount = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_channel_groups_amount_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                   amount);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_channel_groups_v1(
    KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, bool radio)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CHANNEL_GROUPS_V1)( KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, bool radio);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, bool> msgChild__IN_kodi_addon_pvr_get_channel_groups_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_get_channel_groups_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_channel_groups_v1(PtrValue(hdl),
                                                                        PtrValue(handle), radio));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_channel_groups_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_channel_groups_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_channel_groups_v1(m_ifcToAddon->thisClassHdl, hdl, handle,
                                                            radio);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_channel_group_members_v1(
    KODI_ADDON_PVR_HDL hdl,
    KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct PVR_CHANNEL_GROUP* group)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_CHANNEL_GROUP_MEMBERS_V1)( KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, const struct PVR_CHANNEL_GROUP* group);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, IFC_PVR_CHANNEL_GROUP> msgChild__IN_kodi_addon_pvr_get_channel_group_members_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_get_channel_group_members_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_channel_group_members_v1(
                          PtrValue(hdl), PtrValue(handle), group));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_channel_group_members_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_channel_group_members_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_channel_group_members_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                   handle, group);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_delete_channel_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_DELETE_CHANNEL_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_CHANNEL> msgChild__IN_kodi_addon_pvr_delete_channel_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_delete_channel_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_delete_channel_v1(PtrValue(hdl), channel));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_delete_channel_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_delete_channel_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_delete_channel_v1(m_ifcToAddon->thisClassHdl, hdl, channel);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_rename_channel_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_RENAME_CHANNEL_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_CHANNEL> msgChild__IN_kodi_addon_pvr_rename_channel_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_rename_channel_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_rename_channel_v1(PtrValue(hdl), channel));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_rename_channel_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_rename_channel_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_rename_channel_v1(m_ifcToAddon->thisClassHdl, hdl, channel);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_open_dialog_channel_settings_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_OPEN_DIALOG_CHANNEL_SETTINGS_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_CHANNEL> msgChild__IN_kodi_addon_pvr_open_dialog_channel_settings_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_open_dialog_channel_settings_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_open_dialog_channel_settings_v1(PtrValue(hdl), channel));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_open_dialog_channel_settings_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_open_dialog_channel_settings_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_open_dialog_channel_settings_v1(m_ifcToAddon->thisClassHdl,
                                                                      hdl, channel);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_open_dialog_channel_add_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_OPEN_DIALOG_CHANNEL_ADD_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_CHANNEL* channel);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_CHANNEL> msgChild__IN_kodi_addon_pvr_open_dialog_channel_add_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_open_dialog_channel_add_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_open_dialog_channel_add_v1(PtrValue(hdl), channel));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_open_dialog_channel_add_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_open_dialog_channel_add_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_open_dialog_channel_add_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                 channel);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_open_dialog_channel_scan_v1(
    KODI_ADDON_PVR_HDL hdl)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_OPEN_DIALOG_CHANNEL_SCAN_V1)( KODI_ADDON_PVR_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_open_dialog_channel_scan_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_open_dialog_channel_scan_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_open_dialog_channel_scan_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_open_dialog_channel_scan_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_open_dialog_channel_scan_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_open_dialog_channel_scan_v1(m_ifcToAddon->thisClassHdl, hdl);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_call_channel_menu_hook_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct PVR_CHANNEL* channel)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_CALL_CHANNEL_MENU_HOOK_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct PVR_CHANNEL* channel);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_MENUHOOK, IFC_PVR_CHANNEL> msgChild__IN_kodi_addon_pvr_call_channel_menu_hook_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_call_channel_menu_hook_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_call_channel_menu_hook_v1(PtrValue(hdl), menuhook,
                                                                            channel));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_call_channel_menu_hook_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_call_channel_menu_hook_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_call_channel_menu_hook_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                menuhook, channel);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_epg_for_channel_v1(
    KODI_ADDON_PVR_HDL hdl,
    KODI_ADDON_PVR_TRANSFER_HDL handle,
    int channel_uid,
    time_t start,
    time_t end)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_EPG_FOR_CHANNEL_V1)( KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, int channel_uid, time_t start, time_t end);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, int, time_t, time_t> msgChild__IN_kodi_addon_pvr_get_epg_for_channel_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_get_epg_for_channel_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_epg_for_channel_v1(
                          PtrValue(hdl), PtrValue(handle), channel_uid, start, end));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_epg_for_channel_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_epg_for_channel_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_epg_for_channel_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                             handle, channel_uid, start, end);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_is_epg_tag_recordable_v1(
    KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, bool* is_recordable)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_IS_EPG_TAG_RECORDABLE_V1)( KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, bool* is_recordable);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_EPG_TAG, bool> msgChild__IN_kodi_addon_pvr_is_epg_tag_recordable_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, bool> msgChild_OUT_kodi_addon_pvr_is_epg_tag_recordable_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_is_epg_tag_recordable_v1(PtrValue(hdl), tag,
                                                                           *is_recordable));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_is_epg_tag_recordable_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_is_epg_tag_recordable_v1 t = ident.get().as<decltype(t)>();
    *is_recordable = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_is_epg_tag_recordable_v1(m_ifcToAddon->thisClassHdl, hdl, tag,
                                                               is_recordable);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_is_epg_tag_playable_v1(
    KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, bool* is_playable)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_IS_EPG_TAG_PLAYABLE_V1)( KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, bool* is_playable);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_EPG_TAG, bool> msgChild__IN_kodi_addon_pvr_is_epg_tag_playable_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, bool> msgChild_OUT_kodi_addon_pvr_is_epg_tag_playable_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_is_epg_tag_playable_v1(PtrValue(hdl), tag, *is_playable));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_is_epg_tag_playable_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_is_epg_tag_playable_v1 t = ident.get().as<decltype(t)>();
    *is_playable = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_is_epg_tag_playable_v1(m_ifcToAddon->thisClassHdl, hdl, tag,
                                                             is_playable);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_epg_tag_edl_v1(
    KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, struct PVR_EDL_ENTRY edl[], size_t* size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_EPG_TAG_EDL_V1)( KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, struct PVR_EDL_ENTRY edl[], size_t* size);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_EPG_TAG, std::vector<IFC_PVR_EDL_ENTRY>, size_t> msgChild__IN_kodi_addon_pvr_get_epg_tag_edl_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::vector<IFC_PVR_EDL_ENTRY>, size_t> msgChild_OUT_kodi_addon_pvr_get_epg_tag_edl_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    std::vector<IFC_PVR_EDL_ENTRY> ifc_edl(*size);
    for (size_t i = 0; i < *size; ++i)
    {
      ifc_edl[i] = IFC_PVR_EDL_ENTRY(&edl[i]);
    }
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_get_epg_tag_edl_v1(PtrValue(hdl), tag, ifc_edl, *size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_epg_tag_edl_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_epg_tag_edl_v1 t = ident.get().as<decltype(t)>();
    std::vector<IFC_PVR_EDL_ENTRY>& ifc_out_edl = std::get<1>(t);
    *size = std::get<2>(t);
    for (size_t i = 0; i < *size; ++i)
    {
      ifc_out_edl[i].SetCStructure(&edl[i]);
    }
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_epg_tag_edl_v1(m_ifcToAddon->thisClassHdl, hdl, tag, edl,
                                                         size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_epg_tag_stream_properties_v1(
    KODI_ADDON_PVR_HDL hdl,
    const struct EPG_TAG* tag,
    struct PVR_NAMED_VALUE* properties,
    size_t* properties_count)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_EPG_TAG_STREAM_PROPERTIES_V1)( KODI_ADDON_PVR_HDL hdl, const struct EPG_TAG* tag, struct PVR_NAMED_VALUE* properties, size_t* properties_count);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_EPG_TAG, size_t> msgChild__IN_kodi_addon_pvr_get_epg_tag_stream_properties_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, IFC_PVR_NAMED_VALUE, size_t> msgChild_OUT_kodi_addon_pvr_get_epg_tag_stream_properties_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_epg_tag_stream_properties_v1(
                          PtrValue(hdl), tag, *properties_count));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_epg_tag_stream_properties_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_epg_tag_stream_properties_v1 t = ident.get().as<decltype(t)>();
    std::get<1>(t).SetCStructure(properties);
    *properties_count = std::get<2>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_epg_tag_stream_properties_v1(
      m_ifcToAddon->thisClassHdl, hdl, tag, properties, properties_count);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_set_epg_max_past_days_v1(
    KODI_ADDON_PVR_HDL hdl, int past_days)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_SET_EPG_MAX_PAST_DAYS_V1)( KODI_ADDON_PVR_HDL hdl, int past_days);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_set_epg_max_past_days_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_set_epg_max_past_days_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_set_epg_max_past_days_v1(PtrValue(hdl), past_days));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_set_epg_max_past_days_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_set_epg_max_past_days_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_set_epg_max_past_days_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                               past_days);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_set_epg_max_future_days_v1(
    KODI_ADDON_PVR_HDL hdl, int future_days)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_SET_EPG_MAX_FUTURE_DAYS_V1)( KODI_ADDON_PVR_HDL hdl, int future_days);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_set_epg_max_future_days_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_set_epg_max_future_days_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_set_epg_max_future_days_v1(PtrValue(hdl), future_days));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_set_epg_max_future_days_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_set_epg_max_future_days_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_set_epg_max_future_days_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                 future_days);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_call_epg_menu_hook_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct EPG_TAG* tag)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_CALL_EPG_MENU_HOOK_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct EPG_TAG* tag);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_MENUHOOK, IFC_EPG_TAG> msgChild__IN_kodi_addon_pvr_call_epg_menu_hook_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_call_epg_menu_hook_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_call_epg_menu_hook_v1(PtrValue(hdl), menuhook, tag));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_call_epg_menu_hook_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_call_epg_menu_hook_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_call_epg_menu_hook_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                            menuhook, tag);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_recordings_amount_v1(
    KODI_ADDON_PVR_HDL hdl, bool deleted, int* amount)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_RECORDINGS_AMOUNT_V1)( KODI_ADDON_PVR_HDL hdl, bool deleted, int* amount);
  // Tuple in:          typedef std::tuple<PtrValue, bool, int> msgChild__IN_kodi_addon_pvr_get_recordings_amount_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, int> msgChild_OUT_kodi_addon_pvr_get_recordings_amount_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_get_recordings_amount_v1(PtrValue(hdl), deleted, *amount));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_recordings_amount_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_recordings_amount_v1 t = ident.get().as<decltype(t)>();
    *amount = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_recordings_amount_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                               deleted, amount);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_recordings_v1(
    KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, bool deleted)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_RECORDINGS_V1)( KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle, bool deleted);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue, bool> msgChild__IN_kodi_addon_pvr_get_recordings_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_get_recordings_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_recordings_v1(PtrValue(hdl), PtrValue(handle),
                                                                    deleted));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_recordings_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_recordings_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_recordings_v1(m_ifcToAddon->thisClassHdl, hdl, handle,
                                                        deleted);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_delete_recording_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_DELETE_RECORDING_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING> msgChild__IN_kodi_addon_pvr_delete_recording_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_delete_recording_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_delete_recording_v1(PtrValue(hdl), recording));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_delete_recording_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_delete_recording_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_delete_recording_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                          recording);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_undelete_recording_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_UNDELETE_RECORDING_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING> msgChild__IN_kodi_addon_pvr_undelete_recording_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_undelete_recording_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_undelete_recording_v1(PtrValue(hdl), recording));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_undelete_recording_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_undelete_recording_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_undelete_recording_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                            recording);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_delete_all_recordings_from_trash_v1(
    KODI_ADDON_PVR_HDL hdl)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_DELETE_ALL_RECORDINGS_FROM_TRASH_V1)( KODI_ADDON_PVR_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_delete_all_recordings_from_trash_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_delete_all_recordings_from_trash_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_delete_all_recordings_from_trash_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_delete_all_recordings_from_trash_v1, in,
                                out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_delete_all_recordings_from_trash_v1 t =
        ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_delete_all_recordings_from_trash_v1(
      m_ifcToAddon->thisClassHdl, hdl);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_rename_recording_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_RENAME_RECORDING_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING> msgChild__IN_kodi_addon_pvr_rename_recording_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_rename_recording_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_rename_recording_v1(PtrValue(hdl), recording));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_rename_recording_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_rename_recording_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_rename_recording_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                          recording);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_set_recording_lifetime_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_SET_RECORDING_LIFETIME_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING> msgChild__IN_kodi_addon_pvr_set_recording_lifetime_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_set_recording_lifetime_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_set_recording_lifetime_v1(PtrValue(hdl), recording));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_set_recording_lifetime_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_set_recording_lifetime_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_set_recording_lifetime_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                recording);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_set_recording_play_count_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int count)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_SET_RECORDING_PLAY_COUNT_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int count);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING, int> msgChild__IN_kodi_addon_pvr_set_recording_play_count_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_set_recording_play_count_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_set_recording_play_count_v1(PtrValue(hdl),
                                                                              recording, count));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_set_recording_play_count_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_set_recording_play_count_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_set_recording_play_count_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                  recording, count);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_set_recording_last_played_position_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int last_played_position)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_SET_RECORDING_LAST_PLAYED_POSITION_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int last_played_position);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING, int> msgChild__IN_kodi_addon_pvr_set_recording_last_played_position_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_set_recording_last_played_position_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_set_recording_last_played_position_v1(
                          PtrValue(hdl), recording, last_played_position));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_set_recording_last_played_position_v1, in,
                                out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_set_recording_last_played_position_v1 t =
        ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_set_recording_last_played_position_v1(
      m_ifcToAddon->thisClassHdl, hdl, recording, last_played_position);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_recording_last_played_position_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int* last_played_position)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_RECORDING_LAST_PLAYED_POSITION_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int* last_played_position);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING, int> msgChild__IN_kodi_addon_pvr_get_recording_last_played_position_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, int> msgChild_OUT_kodi_addon_pvr_get_recording_last_played_position_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_recording_last_played_position_v1(
                          PtrValue(hdl), recording, *last_played_position));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_recording_last_played_position_v1, in,
                                out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_recording_last_played_position_v1 t =
        ident.get().as<decltype(t)>();
    *last_played_position = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_recording_last_played_position_v1(
      m_ifcToAddon->thisClassHdl, hdl, recording, last_played_position);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_recording_edl_v1(
    KODI_ADDON_PVR_HDL hdl,
    const struct PVR_RECORDING* recording,
    struct PVR_EDL_ENTRY edl[],
    size_t* size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_RECORDING_EDL_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, struct PVR_EDL_ENTRY edl[], size_t* size);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING, std::vector<IFC_PVR_EDL_ENTRY>, size_t> msgChild__IN_kodi_addon_pvr_get_recording_edl_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::vector<IFC_PVR_EDL_ENTRY>, size_t> msgChild_OUT_kodi_addon_pvr_get_recording_edl_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    std::vector<IFC_PVR_EDL_ENTRY> ifc_edl(*size);
    for (size_t i = 0; i < *size; ++i)
    {
      ifc_edl[i] = IFC_PVR_EDL_ENTRY(&edl[i]);
    }
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_recording_edl_v1(PtrValue(hdl), recording,
                                                                       ifc_edl, *size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_recording_edl_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_recording_edl_v1 t = ident.get().as<decltype(t)>();
    std::vector<IFC_PVR_EDL_ENTRY>& ifc_out_edl = std::get<1>(t);
    *size = std::get<2>(t);
    for (size_t i = 0; i < *size; ++i)
    {
      ifc_out_edl[i].SetCStructure(&edl[i]);
    }
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_recording_edl_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                           recording, edl, size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_recording_size_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int64_t* size)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_RECORDING_SIZE_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, int64_t* size);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING, int64_t> msgChild__IN_kodi_addon_pvr_get_recording_size_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, int64_t> msgChild_OUT_kodi_addon_pvr_get_recording_size_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_get_recording_size_v1(PtrValue(hdl), recording, *size));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_recording_size_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_recording_size_v1 t = ident.get().as<decltype(t)>();
    *size = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_recording_size_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                            recording, size);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_recording_stream_properties_v1(
    KODI_ADDON_PVR_HDL hdl,
    const struct PVR_RECORDING* recording,
    struct PVR_NAMED_VALUE* properties,
    size_t* properties_count)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_RECORDING_STREAM_PROPERTIES_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_RECORDING* recording, struct PVR_NAMED_VALUE* properties, size_t* properties_count);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_RECORDING, size_t> msgChild__IN_kodi_addon_pvr_get_recording_stream_properties_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, IFC_PVR_NAMED_VALUE, size_t> msgChild_OUT_kodi_addon_pvr_get_recording_stream_properties_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_recording_stream_properties_v1(
                          PtrValue(hdl), recording, *properties_count));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_recording_stream_properties_v1, in,
                                out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_recording_stream_properties_v1 t =
        ident.get().as<decltype(t)>();
    std::get<1>(t).SetCStructure(properties);
    *properties_count = std::get<2>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_recording_stream_properties_v1(
      m_ifcToAddon->thisClassHdl, hdl, recording, properties, properties_count);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_call_recording_menu_hook_v1(
    KODI_ADDON_PVR_HDL hdl,
    const struct PVR_MENUHOOK* menuhook,
    const struct PVR_RECORDING* recording)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_CALL_RECORDING_MENU_HOOK_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct PVR_RECORDING* recording);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_MENUHOOK, IFC_PVR_RECORDING> msgChild__IN_kodi_addon_pvr_call_recording_menu_hook_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_call_recording_menu_hook_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_call_recording_menu_hook_v1(PtrValue(hdl),
                                                                              menuhook, recording));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_call_recording_menu_hook_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_call_recording_menu_hook_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_call_recording_menu_hook_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                                  menuhook, recording);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_timer_types_v1(
    KODI_ADDON_PVR_HDL hdl, struct PVR_TIMER_TYPE types[], size_t* types_count)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_TIMER_TYPES_V1)( KODI_ADDON_PVR_HDL hdl, struct PVR_TIMER_TYPE types[], size_t* types_count);
  // Tuple in:          typedef std::tuple<PtrValue, std::vector<IFC_PVR_TIMER_TYPE>, size_t> msgChild__IN_kodi_addon_pvr_get_timer_types_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, std::vector<IFC_PVR_TIMER_TYPE>, size_t> msgChild_OUT_kodi_addon_pvr_get_timer_types_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    std::vector<IFC_PVR_TIMER_TYPE> ifc_types(*types_count);
    for (size_t i = 0; i < *types_count; ++i)
    {
      ifc_types[i] = IFC_PVR_TIMER_TYPE(&types[i]);
    }
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_get_timer_types_v1(PtrValue(hdl), ifc_types, *types_count));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_timer_types_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_timer_types_v1 t = ident.get().as<decltype(t)>();
    std::vector<IFC_PVR_TIMER_TYPE>& ifc_out_types = std::get<1>(t);
    *types_count = std::get<2>(t);
    for (size_t i = 0; i < *types_count; ++i)
    {
      ifc_out_types[i].SetCStructure(&types[i]);
    }
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_timer_types_v1(m_ifcToAddon->thisClassHdl, hdl, types,
                                                         types_count);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_timers_amount_v1(
    KODI_ADDON_PVR_HDL hdl, int* amount)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_TIMERS_AMOUNT_V1)( KODI_ADDON_PVR_HDL hdl, int* amount);
  // Tuple in:          typedef std::tuple<PtrValue, int> msgChild__IN_kodi_addon_pvr_get_timers_amount_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR, int> msgChild_OUT_kodi_addon_pvr_get_timers_amount_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_timers_amount_v1(PtrValue(hdl), *amount));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_timers_amount_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_timers_amount_v1 t = ident.get().as<decltype(t)>();
    *amount = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_timers_amount_v1(m_ifcToAddon->thisClassHdl, hdl, amount);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_timers_v1(
    KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_GET_TIMERS_V1)( KODI_ADDON_PVR_HDL hdl, KODI_ADDON_PVR_TRANSFER_HDL handle);
  // Tuple in:          typedef std::tuple<PtrValue, PtrValue> msgChild__IN_kodi_addon_pvr_get_timers_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_get_timers_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_get_timers_v1(PtrValue(hdl), PtrValue(handle)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_get_timers_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_get_timers_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_get_timers_v1(m_ifcToAddon->thisClassHdl, hdl, handle);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_add_timer_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_TIMER* timer)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_ADD_TIMER_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_TIMER* timer);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_TIMER> msgChild__IN_kodi_addon_pvr_add_timer_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_add_timer_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_add_timer_v1(PtrValue(hdl), timer));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_add_timer_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_add_timer_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_add_timer_v1(m_ifcToAddon->thisClassHdl, hdl, timer);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_delete_timer_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_TIMER* timer, bool force_delete)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_DELETE_TIMER_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_TIMER* timer, bool force_delete);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_TIMER, bool> msgChild__IN_kodi_addon_pvr_delete_timer_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_delete_timer_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgChild__IN_kodi_addon_pvr_delete_timer_v1(PtrValue(hdl), timer, force_delete));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_delete_timer_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_delete_timer_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_delete_timer_v1(m_ifcToAddon->thisClassHdl, hdl, timer,
                                                      force_delete);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_update_timer_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_TIMER* timer)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_UPDATE_TIMER_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_TIMER* timer);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_TIMER> msgChild__IN_kodi_addon_pvr_update_timer_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_update_timer_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_update_timer_v1(PtrValue(hdl), timer));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_update_timer_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_update_timer_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_update_timer_v1(m_ifcToAddon->thisClassHdl, hdl, timer);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_call_timer_menu_hook_v1(
    KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct PVR_TIMER* timer)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_CALL_TIMER_MENU_HOOK_V1)( KODI_ADDON_PVR_HDL hdl, const struct PVR_MENUHOOK* menuhook, const struct PVR_TIMER* timer);
  // Tuple in:          typedef std::tuple<PtrValue, IFC_PVR_MENUHOOK, IFC_PVR_TIMER> msgChild__IN_kodi_addon_pvr_call_timer_menu_hook_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_call_timer_menu_hook_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgChild__IN_kodi_addon_pvr_call_timer_menu_hook_v1(PtrValue(hdl), menuhook, timer));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_call_timer_menu_hook_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_call_timer_menu_hook_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_call_timer_menu_hook_v1(m_ifcToAddon->thisClassHdl, hdl,
                                                              menuhook, timer);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_on_system_sleep_v1(
    KODI_ADDON_PVR_HDL hdl)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_ON_SYSTEM_SLEEP_V1)( KODI_ADDON_PVR_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_on_system_sleep_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_on_system_sleep_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_on_system_sleep_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_on_system_sleep_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_on_system_sleep_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_on_system_sleep_v1(m_ifcToAddon->thisClassHdl, hdl);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_on_system_wake_v1(
    KODI_ADDON_PVR_HDL hdl)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_ON_SYSTEM_WAKE_V1)( KODI_ADDON_PVR_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_on_system_wake_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_on_system_wake_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_on_system_wake_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_on_system_wake_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_on_system_wake_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_on_system_wake_v1(m_ifcToAddon->thisClassHdl, hdl);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_on_power_saving_activated_v1(
    KODI_ADDON_PVR_HDL hdl)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_ON_POWER_SAVING_ACTIVATED_V1)( KODI_ADDON_PVR_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_on_power_saving_activated_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_on_power_saving_activated_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_on_power_saving_activated_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_on_power_saving_activated_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_on_power_saving_activated_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_on_power_saving_activated_v1(m_ifcToAddon->thisClassHdl, hdl);
}

enum PVR_ERROR CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_on_power_saving_deactivated_v1(
    KODI_ADDON_PVR_HDL hdl)
{
  // Original API call: typedef enum PVR_ERROR(ATTR_APIENTRYP PFN_KODI_ADDON_PVR_ON_POWER_SAVING_DEACTIVATED_V1)( KODI_ADDON_PVR_HDL hdl);
  // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_pvr_on_power_saving_deactivated_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PVR_ERROR> msgChild_OUT_kodi_addon_pvr_on_power_saving_deactivated_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!m_interface.m_directDll)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgChild__IN_kodi_addon_pvr_on_power_saving_deactivated_v1(PtrValue(hdl)));
    if (!m_process->SendMessage(funcGroup_addoninstance_pvr_h,
                                funcChild_kodi_addon_pvr_on_power_saving_deactivated_v1, in, out))
      return PVR_ERROR_NO_ERROR;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgChild_OUT_kodi_addon_pvr_on_power_saving_deactivated_v1 t = ident.get().as<decltype(t)>();
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  return m_ifcToAddon->kodi_addon_pvr_on_power_saving_deactivated_v1(m_ifcToAddon->thisClassHdl,
                                                                     hdl);
}

// Callbacks from addon to Kodi

int CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_epg_max_future_days_v1(void* thisClassHdl,
                                                                             KODI_OWN_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_GET_EPG_MAX_FUTURE_DAYS>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "int cb_get_epg_max_future_days()" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  return cb->cb_get_epg_max_future_days();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_GET_EPG_MAX_FUTURE_DAYS_END>---*/
}

int CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_get_epg_max_past_days_v1(void* thisClassHdl,
                                                                           KODI_OWN_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_GET_EPG_MAX_PAST_DAYS>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "int cb_get_epg_max_past_days()" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  return cb->cb_get_epg_max_past_days();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_GET_EPG_MAX_PAST_DAYS_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_add_menu_hook_v1(void* thisClassHdl,
                                                                    KODI_OWN_HDL hdl,
                                                                    const struct PVR_MENUHOOK* hook)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_ADD_MENU_HOOK>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_add_menu_hook(const PVR_MENUHOOK* hook)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_add_menu_hook(hook);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_ADD_MENU_HOOK_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_recording_notification_v1(
    void* thisClassHdl, KODI_OWN_HDL hdl, const char* name, const char* fileName, bool on)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_RECORDING_NOTIFICATION>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_recording_notification(const char* strName,const char* strFileName,bool bOnOff)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_recording_notification(name, fileName, on);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_RECORDING_NOTIFICATION_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_connection_state_change_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const char* strConnectionString,
    enum PVR_CONNECTION_STATE newState,
    const char* strMessage)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_CONNECTION_STATE_CHANGE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_connection_state_change(const char* strConnectionString,PVR_CONNECTION_STATE newState,const char* strMessage)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_connection_state_change(strConnectionString, newState, strMessage);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_CONNECTION_STATE_CHANGE_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_epg_event_state_change_v1(
    void* thisClassHdl, KODI_OWN_HDL hdl, struct EPG_TAG* tag, enum EPG_EVENT_STATE newState)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_EPG_EVENT_STATE_CHANGE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_epg_event_state_change(EPG_TAG* tag, EPG_EVENT_STATE newState)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_epg_event_state_change(tag, newState);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_EPG_EVENT_STATE_CHANGE_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_transfer_channel_entry_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct PVR_CHANNEL* chan)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_CHANNEL_ENTRY>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_transfer_channel_entry(const KODI_ADDON_PVR_TRANSFER_HDL handle,const PVR_CHANNEL* entry)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_transfer_channel_entry(handle, chan);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_CHANNEL_ENTRY_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_transfer_channel_group_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct PVR_CHANNEL_GROUP* group)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_CHANNEL_GROUP>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_transfer_channel_group(const KODI_ADDON_PVR_TRANSFER_HDL handle,const PVR_CHANNEL_GROUP* entry)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_transfer_channel_group(handle, group);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_CHANNEL_GROUP_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_transfer_channel_group_member_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct PVR_CHANNEL_GROUP_MEMBER* member)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_CHANNEL_GROUP_MEMBER>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_transfer_channel_group_member(const KODI_ADDON_PVR_TRANSFER_HDL handle,const PVR_CHANNEL_GROUP_MEMBER* entry)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_transfer_channel_group_member(handle, member);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_CHANNEL_GROUP_MEMBER_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_transfer_epg_entry_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct EPG_TAG* epgentry)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_EPG_ENTRY>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_transfer_epg_entry(const KODI_ADDON_PVR_TRANSFER_HDL handle,const EPG_TAG* entry)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_transfer_epg_entry(handle, epgentry);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_EPG_ENTRY_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_transfer_recording_entry_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct PVR_RECORDING* recording)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_RECORDING_ENTRY>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_transfer_recording_entry(const KODI_ADDON_PVR_TRANSFER_HDL handle,const PVR_RECORDING* entry)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_transfer_recording_entry(handle, recording);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_RECORDING_ENTRY_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_transfer_timer_entry_v1(
    void* thisClassHdl,
    KODI_OWN_HDL hdl,
    const KODI_ADDON_PVR_TRANSFER_HDL handle,
    const struct PVR_TIMER* timer)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_TIMER_ENTRY>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_transfer_timer_entry(const KODI_ADDON_PVR_TRANSFER_HDL handle,const PVR_TIMER* entry)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_transfer_timer_entry(handle, timer);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRANSFER_TIMER_ENTRY_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_trigger_channel_update_v1(void* thisClassHdl,
                                                                             KODI_OWN_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_CHANNEL_UPDATE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_trigger_channel_update()" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_trigger_channel_update();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_CHANNEL_UPDATE_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_trigger_channel_groups_update_v1(
    void* thisClassHdl, KODI_OWN_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_CHANNEL_GROUPS_UPDATE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_trigger_channel_groups_update()" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_trigger_channel_groups_update();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_CHANNEL_GROUPS_UPDATE_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_trigger_epg_update_v1(void* thisClassHdl,
                                                                         KODI_OWN_HDL hdl,
                                                                         unsigned int iChannelUid)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_EPG_UPDATE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_trigger_epg_update(unsigned int iChannelUid)" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_trigger_epg_update(iChannelUid);
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_EPG_UPDATE_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_trigger_recording_update_v1(void* thisClassHdl,
                                                                               KODI_OWN_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_RECORDING_UPDATE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_trigger_recording_update()" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_trigger_recording_update();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_RECORDING_UPDATE_END>---*/
}

void CHdl_kodi_addoninstance_pvr_h::kodi_addon_pvr_trigger_timer_update_v1(void* thisClassHdl,
                                                                           KODI_OWN_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addoninstance_pvr_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_TIMER_UPDATE>---*/
  // AUTOGENERATED - Used by class "PVR::CPVRClient" with "void cb_trigger_timer_update()" on "pvr/addons/PVRClient.h".

  PVR::CPVRClient* cb = static_cast<PVR::CPVRClient*>(hdl);
  cb->cb_trigger_timer_update();
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_PVR_TRIGGER_TIMER_UPDATE_END>---*/
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

} /* namespace INTERFACE */
} /* namespace ADDONS */
} /* namespace KODI */
