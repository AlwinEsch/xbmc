/*
 *  Copyright (C) 2005-2021 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "audio_engine.h"

// Shared API
#include "addons/kodi-dev-kit/src/shared/api/audio_engine.h"

// Kodi
#include "addons/interface/RunningProcess.h"
#include "utils/log.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
#include "ServiceBroker.h"
#include "cores/AudioEngine/Interfaces/AE.h"
#include "cores/AudioEngine/Interfaces/AEStream.h"
#include "cores/AudioEngine/Utils/AEStreamData.h"
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

namespace KODI
{
namespace ADDONS
{
namespace INTERFACE
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/
AEChannel TranslateAEChannelToKodi(AudioEngineChannel channel)
{
  switch (channel)
  {
    case AUDIOENGINE_CH_RAW:
      return AE_CH_RAW;
    case AUDIOENGINE_CH_FL:
      return AE_CH_FL;
    case AUDIOENGINE_CH_FR:
      return AE_CH_FR;
    case AUDIOENGINE_CH_FC:
      return AE_CH_FC;
    case AUDIOENGINE_CH_LFE:
      return AE_CH_LFE;
    case AUDIOENGINE_CH_BL:
      return AE_CH_BL;
    case AUDIOENGINE_CH_BR:
      return AE_CH_BR;
    case AUDIOENGINE_CH_FLOC:
      return AE_CH_FLOC;
    case AUDIOENGINE_CH_FROC:
      return AE_CH_FROC;
    case AUDIOENGINE_CH_BC:
      return AE_CH_BC;
    case AUDIOENGINE_CH_SL:
      return AE_CH_SL;
    case AUDIOENGINE_CH_SR:
      return AE_CH_SR;
    case AUDIOENGINE_CH_TFL:
      return AE_CH_TFL;
    case AUDIOENGINE_CH_TFR:
      return AE_CH_TFR;
    case AUDIOENGINE_CH_TFC:
      return AE_CH_TFC;
    case AUDIOENGINE_CH_TC:
      return AE_CH_TC;
    case AUDIOENGINE_CH_TBL:
      return AE_CH_TBL;
    case AUDIOENGINE_CH_TBR:
      return AE_CH_TBR;
    case AUDIOENGINE_CH_TBC:
      return AE_CH_TBC;
    case AUDIOENGINE_CH_BLOC:
      return AE_CH_BLOC;
    case AUDIOENGINE_CH_BROC:
      return AE_CH_BROC;
    case AUDIOENGINE_CH_MAX:
      return AE_CH_MAX;
    case AUDIOENGINE_CH_NULL:
    default:
      return AE_CH_NULL;
  }
}

AudioEngineChannel TranslateAEChannelToAddon(AEChannel channel)
{
  switch (channel)
  {
    case AE_CH_RAW:
      return AUDIOENGINE_CH_RAW;
    case AE_CH_FL:
      return AUDIOENGINE_CH_FL;
    case AE_CH_FR:
      return AUDIOENGINE_CH_FR;
    case AE_CH_FC:
      return AUDIOENGINE_CH_FC;
    case AE_CH_LFE:
      return AUDIOENGINE_CH_LFE;
    case AE_CH_BL:
      return AUDIOENGINE_CH_BL;
    case AE_CH_BR:
      return AUDIOENGINE_CH_BR;
    case AE_CH_FLOC:
      return AUDIOENGINE_CH_FLOC;
    case AE_CH_FROC:
      return AUDIOENGINE_CH_FROC;
    case AE_CH_BC:
      return AUDIOENGINE_CH_BC;
    case AE_CH_SL:
      return AUDIOENGINE_CH_SL;
    case AE_CH_SR:
      return AUDIOENGINE_CH_SR;
    case AE_CH_TFL:
      return AUDIOENGINE_CH_TFL;
    case AE_CH_TFR:
      return AUDIOENGINE_CH_TFR;
    case AE_CH_TFC:
      return AUDIOENGINE_CH_TFC;
    case AE_CH_TC:
      return AUDIOENGINE_CH_TC;
    case AE_CH_TBL:
      return AUDIOENGINE_CH_TBL;
    case AE_CH_TBR:
      return AUDIOENGINE_CH_TBR;
    case AE_CH_TBC:
      return AUDIOENGINE_CH_TBC;
    case AE_CH_BLOC:
      return AUDIOENGINE_CH_BLOC;
    case AE_CH_BROC:
      return AUDIOENGINE_CH_BROC;
    case AE_CH_MAX:
      return AUDIOENGINE_CH_MAX;
    case AE_CH_NULL:
    default:
      return AUDIOENGINE_CH_NULL;
  }
}

AEDataFormat TranslateAEFormatToKodi(AudioEngineDataFormat format)
{
  switch (format)
  {
    case AUDIOENGINE_FMT_U8:
      return AE_FMT_U8;
    case AUDIOENGINE_FMT_S16BE:
      return AE_FMT_S16BE;
    case AUDIOENGINE_FMT_S16LE:
      return AE_FMT_S16LE;
    case AUDIOENGINE_FMT_S16NE:
      return AE_FMT_S16NE;
    case AUDIOENGINE_FMT_S32BE:
      return AE_FMT_S32BE;
    case AUDIOENGINE_FMT_S32LE:
      return AE_FMT_S32LE;
    case AUDIOENGINE_FMT_S32NE:
      return AE_FMT_S32NE;
    case AUDIOENGINE_FMT_S24BE4:
      return AE_FMT_S24BE4;
    case AUDIOENGINE_FMT_S24LE4:
      return AE_FMT_S24LE4;
    case AUDIOENGINE_FMT_S24NE4:
      return AE_FMT_S24NE4;
    case AUDIOENGINE_FMT_S24NE4MSB:
      return AE_FMT_S24NE4MSB;
    case AUDIOENGINE_FMT_S24BE3:
      return AE_FMT_S24BE3;
    case AUDIOENGINE_FMT_S24LE3:
      return AE_FMT_S24LE3;
    case AUDIOENGINE_FMT_S24NE3:
      return AE_FMT_S24NE3;
    case AUDIOENGINE_FMT_DOUBLE:
      return AE_FMT_DOUBLE;
    case AUDIOENGINE_FMT_FLOAT:
      return AE_FMT_FLOAT;
    case AUDIOENGINE_FMT_RAW:
      return AE_FMT_RAW;
    case AUDIOENGINE_FMT_U8P:
      return AE_FMT_U8P;
    case AUDIOENGINE_FMT_S16NEP:
      return AE_FMT_S16NEP;
    case AUDIOENGINE_FMT_S32NEP:
      return AE_FMT_S32NEP;
    case AUDIOENGINE_FMT_S24NE4P:
      return AE_FMT_S24NE4P;
    case AUDIOENGINE_FMT_S24NE4MSBP:
      return AE_FMT_S24NE4MSBP;
    case AUDIOENGINE_FMT_S24NE3P:
      return AE_FMT_S24NE3P;
    case AUDIOENGINE_FMT_DOUBLEP:
      return AE_FMT_DOUBLEP;
    case AUDIOENGINE_FMT_FLOATP:
      return AE_FMT_FLOATP;
    case AUDIOENGINE_FMT_MAX:
      return AE_FMT_MAX;
    case AUDIOENGINE_FMT_INVALID:
    default:
      return AE_FMT_INVALID;
  }
}

AudioEngineDataFormat TranslateAEFormatToAddon(AEDataFormat format)
{
  switch (format)
  {
    case AE_FMT_U8:
      return AUDIOENGINE_FMT_U8;
    case AE_FMT_S16BE:
      return AUDIOENGINE_FMT_S16BE;
    case AE_FMT_S16LE:
      return AUDIOENGINE_FMT_S16LE;
    case AE_FMT_S16NE:
      return AUDIOENGINE_FMT_S16NE;
    case AE_FMT_S32BE:
      return AUDIOENGINE_FMT_S32BE;
    case AE_FMT_S32LE:
      return AUDIOENGINE_FMT_S32LE;
    case AE_FMT_S32NE:
      return AUDIOENGINE_FMT_S32NE;
    case AE_FMT_S24BE4:
      return AUDIOENGINE_FMT_S24BE4;
    case AE_FMT_S24LE4:
      return AUDIOENGINE_FMT_S24LE4;
    case AE_FMT_S24NE4:
      return AUDIOENGINE_FMT_S24NE4;
    case AE_FMT_S24NE4MSB:
      return AUDIOENGINE_FMT_S24NE4MSB;
    case AE_FMT_S24BE3:
      return AUDIOENGINE_FMT_S24BE3;
    case AE_FMT_S24LE3:
      return AUDIOENGINE_FMT_S24LE3;
    case AE_FMT_S24NE3:
      return AUDIOENGINE_FMT_S24NE3;
    case AE_FMT_DOUBLE:
      return AUDIOENGINE_FMT_DOUBLE;
    case AE_FMT_FLOAT:
      return AUDIOENGINE_FMT_FLOAT;
    case AE_FMT_RAW:
      return AUDIOENGINE_FMT_RAW;
    case AE_FMT_U8P:
      return AUDIOENGINE_FMT_U8P;
    case AE_FMT_S16NEP:
      return AUDIOENGINE_FMT_S16NEP;
    case AE_FMT_S32NEP:
      return AUDIOENGINE_FMT_S32NEP;
    case AE_FMT_S24NE4P:
      return AUDIOENGINE_FMT_S24NE4P;
    case AE_FMT_S24NE4MSBP:
      return AUDIOENGINE_FMT_S24NE4MSBP;
    case AE_FMT_S24NE3P:
      return AUDIOENGINE_FMT_S24NE3P;
    case AE_FMT_DOUBLEP:
      return AUDIOENGINE_FMT_DOUBLEP;
    case AE_FMT_FLOATP:
      return AUDIOENGINE_FMT_FLOATP;
    case AE_FMT_MAX:
      return AUDIOENGINE_FMT_MAX;
    case AE_FMT_INVALID:
    default:
      return AUDIOENGINE_FMT_INVALID;
  }
}

class CAddonAudioStream : public IInterfaceClassHdl
{
public:
  CAddonAudioStream() : IInterfaceClassHdl(InterfaceKodiClass::IAEStream) {}

  IAEStream* m_stream;
};

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_audio_engine_h::InitDirect(directFuncToKodi_audio_engine_h* ifcToKodi,
                                          directFuncToAddon_audio_engine_h* ifcToAddon)
{
  ifcToKodi->thisClassHdl = this;
  m_ifcToAddon = ifcToAddon;
  ifcToKodi->kodi_audioengine_get_current_sink_format_v1 =
      kodi_audioengine_get_current_sink_format_v1;
  ifcToKodi->kodi_audioengine_is_planar_format_v1 = kodi_audioengine_is_planar_format_v1;
  ifcToKodi->kodi_audioengine_stream_make_v1 = kodi_audioengine_stream_make_v1;
  ifcToKodi->kodi_audioengine_stream_free_v1 = kodi_audioengine_stream_free_v1;
  ifcToKodi->kodi_audioengine_stream_get_space_v1 = kodi_audioengine_stream_get_space_v1;
  ifcToKodi->kodi_audioengine_stream_add_data_v1 = kodi_audioengine_stream_add_data_v1;
  ifcToKodi->kodi_audioengine_stream_get_delay_v1 = kodi_audioengine_stream_get_delay_v1;
  ifcToKodi->kodi_audioengine_stream_is_buffering_v1 = kodi_audioengine_stream_is_buffering_v1;
  ifcToKodi->kodi_audioengine_stream_get_cache_time_v1 = kodi_audioengine_stream_get_cache_time_v1;
  ifcToKodi->kodi_audioengine_stream_get_cache_total_v1 =
      kodi_audioengine_stream_get_cache_total_v1;
  ifcToKodi->kodi_audioengine_stream_pause_v1 = kodi_audioengine_stream_pause_v1;
  ifcToKodi->kodi_audioengine_stream_resume_v1 = kodi_audioengine_stream_resume_v1;
  ifcToKodi->kodi_audioengine_stream_drain_v1 = kodi_audioengine_stream_drain_v1;
  ifcToKodi->kodi_audioengine_stream_is_draining_v1 = kodi_audioengine_stream_is_draining_v1;
  ifcToKodi->kodi_audioengine_stream_is_drained_v1 = kodi_audioengine_stream_is_drained_v1;
  ifcToKodi->kodi_audioengine_stream_flush_v1 = kodi_audioengine_stream_flush_v1;
  ifcToKodi->kodi_audioengine_stream_get_volume_v1 = kodi_audioengine_stream_get_volume_v1;
  ifcToKodi->kodi_audioengine_stream_set_volume_v1 = kodi_audioengine_stream_set_volume_v1;
  ifcToKodi->kodi_audioengine_stream_get_amplification_v1 =
      kodi_audioengine_stream_get_amplification_v1;
  ifcToKodi->kodi_audioengine_stream_set_amplification_v1 =
      kodi_audioengine_stream_set_amplification_v1;
  ifcToKodi->kodi_audioengine_stream_get_frame_size_v1 = kodi_audioengine_stream_get_frame_size_v1;
  ifcToKodi->kodi_audioengine_stream_get_channel_count_v1 =
      kodi_audioengine_stream_get_channel_count_v1;
  ifcToKodi->kodi_audioengine_stream_get_sample_rate_v1 =
      kodi_audioengine_stream_get_sample_rate_v1;
  ifcToKodi->kodi_audioengine_stream_get_data_format_v1 =
      kodi_audioengine_stream_get_data_format_v1;
  ifcToKodi->kodi_audioengine_stream_get_resample_ratio_v1 =
      kodi_audioengine_stream_get_resample_ratio_v1;
  ifcToKodi->kodi_audioengine_stream_set_resample_ratio_v1 =
      kodi_audioengine_stream_set_resample_ratio_v1;
}

bool CHdl_kodi_audio_engine_h::HandleMessage(int funcGroup,
                                             int func,
                                             const msgpack::unpacked& in,
                                             msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_audio_engine_h)
    return false;

  switch (func)
  {
    case funcParent_kodi_audioengine_get_current_sink_format_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_audioengine_get_current_sink_format(struct AUDIO_ENGINE_FMT* fmt) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_audioengine_get_current_sink_format_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, IFC_AUDIO_ENGINE_FMT> msgParent_OUT_kodi_audioengine_get_current_sink_format_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_get_current_sink_format_v1 t = in.get().as<decltype(t)>();
      struct AUDIO_ENGINE_FMT fmt;
      bool auto_gen_ret = kodi_audioengine_get_current_sink_format_v1(this, &fmt);
      msgpack::pack(out,
                    msgParent_OUT_kodi_audioengine_get_current_sink_format_v1(auto_gen_ret, &fmt));
      return true;
    }
    case funcParent_kodi_audioengine_is_planar_format_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_audioengine_is_planar_format(enum AudioEngineDataFormat format) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<AudioEngineDataFormat> msgParent__IN_kodi_audioengine_is_planar_format_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_audioengine_is_planar_format_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_is_planar_format_v1 t = in.get().as<decltype(t)>();
      enum AudioEngineDataFormat format = std::get<0>(t);
      bool auto_gen_ret = kodi_audioengine_is_planar_format_v1(this, format);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_is_planar_format_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_make_v1:
    {
      // Original API call: ATTR_DLL_EXPORT KODI_AE_HDL kodi_audioengine_stream_make(const struct AUDIO_ENGINE_FMT* fmt, unsigned int options) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<IFC_AUDIO_ENGINE_FMT, unsigned int> msgParent__IN_kodi_audioengine_stream_make_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_audioengine_stream_make_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_make_v1 t = in.get().as<decltype(t)>();
      AUDIO_ENGINE_FMT fmt;
      std::get<0>(t).SetCStructure(&fmt);
      unsigned int options = std::get<1>(t);
      KODI_AE_HDL auto_gen_ret = kodi_audioengine_stream_make_v1(this, &fmt, options);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_make_v1(PtrValue(auto_gen_ret)));
      return true;
    }
    case funcParent_kodi_audioengine_stream_free_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_free(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_free_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_free_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_free_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      kodi_audioengine_stream_free_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_space_v1:
    {
      // Original API call: ATTR_DLL_EXPORT unsigned int kodi_audioengine_stream_get_space(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_space_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<unsigned int> msgParent_OUT_kodi_audioengine_stream_get_space_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_space_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      unsigned int auto_gen_ret = kodi_audioengine_stream_get_space_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_space_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_add_data_v1:
    {
      // Original API call: ATTR_DLL_EXPORT unsigned int kodi_audioengine_stream_add_data(KODI_AE_HDL hdl, uint8_t* const* data, size_t planes, size_t data_size, unsigned int offset, unsigned int frames, unsigned int frame_size, double pts, bool hasDownmix, double centerMixLevel) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::vector<std::vector<uint8_t>>, size_t, size_t, unsigned int, unsigned int, unsigned int, double, bool, double> msgParent__IN_kodi_audioengine_stream_add_data_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<unsigned int> msgParent_OUT_kodi_audioengine_stream_add_data_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_add_data_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      std::vector<std::vector<uint8_t>>& ifc_data = std::get<1>(t);
      size_t planes = std::get<2>(t);
      size_t data_size = std::get<3>(t);
      unsigned int offset = std::get<4>(t);
      unsigned int frames = std::get<5>(t);
      unsigned int frame_size = std::get<6>(t);
      double pts = std::get<7>(t);
      bool hasDownmix = std::get<8>(t);
      double centerMixLevel = std::get<9>(t);
      uint8_t** data = new uint8_t*[ifc_data.size()];
      for (size_t i = 0; i < ifc_data.size(); ++i)
        data[i] = ifc_data[i].data();
      unsigned int auto_gen_ret =
          kodi_audioengine_stream_add_data_v1(this, hdl, data, planes, data_size, offset, frames,
                                              frame_size, pts, hasDownmix, centerMixLevel);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_add_data_v1(auto_gen_ret));
      delete[] data;
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_delay_v1:
    {
      // Original API call: ATTR_DLL_EXPORT double kodi_audioengine_stream_get_delay(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_delay_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<double> msgParent_OUT_kodi_audioengine_stream_get_delay_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_delay_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      double auto_gen_ret = kodi_audioengine_stream_get_delay_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_delay_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_is_buffering_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_audioengine_stream_is_buffering(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_is_buffering_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_audioengine_stream_is_buffering_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_is_buffering_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      bool auto_gen_ret = kodi_audioengine_stream_is_buffering_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_is_buffering_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_cache_time_v1:
    {
      // Original API call: ATTR_DLL_EXPORT double kodi_audioengine_stream_get_cache_time(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_cache_time_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<double> msgParent_OUT_kodi_audioengine_stream_get_cache_time_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_cache_time_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      double auto_gen_ret = kodi_audioengine_stream_get_cache_time_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_cache_time_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_cache_total_v1:
    {
      // Original API call: ATTR_DLL_EXPORT double kodi_audioengine_stream_get_cache_total(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_cache_total_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<double> msgParent_OUT_kodi_audioengine_stream_get_cache_total_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_cache_total_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      double auto_gen_ret = kodi_audioengine_stream_get_cache_total_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_cache_total_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_pause_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_pause(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_pause_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_pause_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_pause_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      kodi_audioengine_stream_pause_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_audioengine_stream_resume_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_resume(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_resume_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_resume_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_resume_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      kodi_audioengine_stream_resume_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_audioengine_stream_drain_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_drain(KODI_AE_HDL hdl, bool wait) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, bool> msgParent__IN_kodi_audioengine_stream_drain_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_drain_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_drain_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      bool wait = std::get<1>(t);
      kodi_audioengine_stream_drain_v1(this, hdl, wait);
      return true;
    }
    case funcParent_kodi_audioengine_stream_is_draining_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_audioengine_stream_is_draining(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_is_draining_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_audioengine_stream_is_draining_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_is_draining_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      bool auto_gen_ret = kodi_audioengine_stream_is_draining_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_is_draining_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_is_drained_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_audioengine_stream_is_drained(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_is_drained_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_audioengine_stream_is_drained_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_is_drained_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      bool auto_gen_ret = kodi_audioengine_stream_is_drained_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_is_drained_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_flush_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_flush(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_flush_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_flush_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_flush_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      kodi_audioengine_stream_flush_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_volume_v1:
    {
      // Original API call: ATTR_DLL_EXPORT float kodi_audioengine_stream_get_volume(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_volume_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<float> msgParent_OUT_kodi_audioengine_stream_get_volume_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_volume_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      float auto_gen_ret = kodi_audioengine_stream_get_volume_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_volume_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_set_volume_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_set_volume(KODI_AE_HDL hdl, float volume) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, float> msgParent__IN_kodi_audioengine_stream_set_volume_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_set_volume_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_set_volume_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      float volume = std::get<1>(t);
      kodi_audioengine_stream_set_volume_v1(this, hdl, volume);
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_amplification_v1:
    {
      // Original API call: ATTR_DLL_EXPORT float kodi_audioengine_stream_get_amplification(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_amplification_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<float> msgParent_OUT_kodi_audioengine_stream_get_amplification_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_amplification_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      float auto_gen_ret = kodi_audioengine_stream_get_amplification_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_amplification_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_set_amplification_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_set_amplification(KODI_AE_HDL hdl, float amplify) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, float> msgParent__IN_kodi_audioengine_stream_set_amplification_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_set_amplification_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_set_amplification_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      float amplify = std::get<1>(t);
      kodi_audioengine_stream_set_amplification_v1(this, hdl, amplify);
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_frame_size_v1:
    {
      // Original API call: ATTR_DLL_EXPORT unsigned int kodi_audioengine_stream_get_frame_size(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_frame_size_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<unsigned int> msgParent_OUT_kodi_audioengine_stream_get_frame_size_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_frame_size_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      unsigned int auto_gen_ret = kodi_audioengine_stream_get_frame_size_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_frame_size_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_channel_count_v1:
    {
      // Original API call: ATTR_DLL_EXPORT unsigned int kodi_audioengine_stream_get_channel_count(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_channel_count_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<unsigned int> msgParent_OUT_kodi_audioengine_stream_get_channel_count_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_channel_count_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      unsigned int auto_gen_ret = kodi_audioengine_stream_get_channel_count_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_channel_count_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_sample_rate_v1:
    {
      // Original API call: ATTR_DLL_EXPORT unsigned int kodi_audioengine_stream_get_sample_rate(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_sample_rate_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<unsigned int> msgParent_OUT_kodi_audioengine_stream_get_sample_rate_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_sample_rate_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      unsigned int auto_gen_ret = kodi_audioengine_stream_get_sample_rate_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_sample_rate_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_data_format_v1:
    {
      // Original API call: ATTR_DLL_EXPORT enum AudioEngineDataFormat kodi_audioengine_stream_get_data_format( KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_data_format_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<AudioEngineDataFormat> msgParent_OUT_kodi_audioengine_stream_get_data_format_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_data_format_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      enum AudioEngineDataFormat auto_gen_ret =
          kodi_audioengine_stream_get_data_format_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_data_format_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_get_resample_ratio_v1:
    {
      // Original API call: ATTR_DLL_EXPORT double kodi_audioengine_stream_get_resample_ratio(KODI_AE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_audioengine_stream_get_resample_ratio_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<double> msgParent_OUT_kodi_audioengine_stream_get_resample_ratio_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_get_resample_ratio_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      double auto_gen_ret = kodi_audioengine_stream_get_resample_ratio_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_audioengine_stream_get_resample_ratio_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_audioengine_stream_set_resample_ratio_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_audioengine_stream_set_resample_ratio(KODI_AE_HDL hdl, double ratio) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, double> msgParent__IN_kodi_audioengine_stream_set_resample_ratio_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_audioengine_stream_set_resample_ratio_v1; /* Autogenerated */
      msgParent__IN_kodi_audioengine_stream_set_resample_ratio_v1 t = in.get().as<decltype(t)>();
      KODI_AE_HDL hdl = reinterpret_cast<KODI_AE_HDL>(std::get<0>(t));
      double ratio = std::get<1>(t);
      kodi_audioengine_stream_set_resample_ratio_v1(this, hdl, ratio);
      return true;
    }
    default:
      CLog::Log(LOGERROR,
                "CHdl_kodi_audio_engine_h::{}: addon called with unknown function id '{}' on group "
                "'audio_engine_h'",
                __func__, func);
  }

  return false;
}

// Function calls from Kodi to addon
/* NOTE: unused (no functions here) */

// Callbacks from addon to Kodi

bool CHdl_kodi_audio_engine_h::kodi_audioengine_get_current_sink_format_v1(
    void* thisClassHdl, struct AUDIO_ENGINE_FMT* fmt)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_GET_CURRENT_SINK_FORMAT>---*/

  IAE* engine = CServiceBroker::GetActiveAE();
  if (!engine)
    return false;

  AEAudioFormat sinkFormat;
  if (!engine->GetCurrentSinkFormat(sinkFormat))
  {
    CLog::Log(LOGERROR, "CHdl_kodi_audio_engine_h::{} - failed to get current sink format from AE!",
              __func__);
    return false;
  }

  fmt->data_format = TranslateAEFormatToAddon(sinkFormat.m_dataFormat);
  fmt->sample_rate = sinkFormat.m_sampleRate;
  fmt->frames = sinkFormat.m_frames;
  fmt->frame_size = sinkFormat.m_frameSize;
  fmt->channel_count = sinkFormat.m_channelLayout.Count();
  for (unsigned int ch = 0; ch < fmt->channel_count && ch < AUDIOENGINE_CH_MAX; ++ch)
  {
    fmt->channels[ch] = TranslateAEChannelToAddon(sinkFormat.m_channelLayout[ch]);
  }

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_GET_CURRENT_SINK_FORMAT_END>---*/
}

bool CHdl_kodi_audio_engine_h::kodi_audioengine_is_planar_format_v1(
    void* thisClassHdl, enum AudioEngineDataFormat format)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_IS_PLANAR_FORMAT>---*/

  if (format >= AUDIOENGINE_FMT_U8P || format <= AUDIOENGINE_FMT_FLOATP)
    return true;
  return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_IS_PLANAR_FORMAT_END>---*/
}

KODI_AE_HDL CHdl_kodi_audio_engine_h::kodi_audioengine_stream_make_v1(
    void* thisClassHdl, const struct AUDIO_ENGINE_FMT* fmt, unsigned int options)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_MAKE>---*/

  IAE* engine = CServiceBroker::GetActiveAE();
  if (!engine)
    return nullptr;

  CAEChannelInfo layout;
  for (unsigned int ch = 0; ch < AUDIOENGINE_CH_MAX; ++ch)
  {
    if (fmt->channels[ch] == AUDIOENGINE_CH_NULL)
      break;
    layout += TranslateAEChannelToKodi(fmt->channels[ch]);
  }

  AEAudioFormat format;
  format.m_channelLayout = layout;
  format.m_dataFormat = TranslateAEFormatToKodi(fmt->data_format);
  format.m_sampleRate = fmt->sample_rate;

  /* Translate addon options to kodi's options */
  int kodiOption = 0;
  if (options & AUDIO_STREAM_FORCE_RESAMPLE)
    kodiOption |= AESTREAM_FORCE_RESAMPLE;
  if (options & AUDIO_STREAM_PAUSED)
    kodiOption |= AESTREAM_PAUSED;
  if (options & AUDIO_STREAM_AUTOSTART)
    kodiOption |= AESTREAM_AUTOSTART;

  CAddonAudioStream* stream = new CAddonAudioStream();
  stream->m_stream = engine->MakeStream(format, kodiOption);
  if (!stream->m_stream)
  {
    delete stream;
    return nullptr;
  }

  thisClass->m_process->RegisterClass(stream);
  return KODI_AE_HDL(stream);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_MAKE_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_free_v1(void* thisClassHdl, KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_FREE>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream)
    return;

  thisClass->m_process->UnregisterClass(stream);
  IAE* engine = CServiceBroker::GetActiveAE();
  if (engine)
    engine->FreeStream(stream->m_stream, true);
  delete stream;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_FREE_END>---*/
}

unsigned int CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_space_v1(void* thisClassHdl,
                                                                            KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_SPACE>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0;

  return stream->m_stream->GetSpace();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_SPACE_END>---*/
}

unsigned int CHdl_kodi_audio_engine_h::kodi_audioengine_stream_add_data_v1(void* thisClassHdl,
                                                                           KODI_AE_HDL hdl,
                                                                           uint8_t* const* data,
                                                                           size_t planes,
                                                                           size_t data_size,
                                                                           unsigned int offset,
                                                                           unsigned int frames,
                                                                           unsigned int frame_size,
                                                                           double pts,
                                                                           bool hasDownmix,
                                                                           double centerMixLevel)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_ADD_DATA>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream || !CServiceBroker::GetActiveAE())
    return 0;

  IAEStream::ExtData extData;
  extData.pts = pts;
  extData.hasDownmix = hasDownmix;
  extData.centerMixLevel = centerMixLevel;

  return stream->m_stream->AddData(data, offset, frames, &extData);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_ADD_DATA_END>---*/
}

double CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_delay_v1(void* thisClassHdl,
                                                                      KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_DELAY>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0.0;

  return stream->m_stream->GetDelay();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_DELAY_END>---*/
}

bool CHdl_kodi_audio_engine_h::kodi_audioengine_stream_is_buffering_v1(void* thisClassHdl,
                                                                       KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_IS_BUFFERING>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return false;

  return stream->m_stream->IsBuffering();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_IS_BUFFERING_END>---*/
}

double CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_cache_time_v1(void* thisClassHdl,
                                                                           KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_CACHE_TIME>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0.0;

  return stream->m_stream->GetCacheTime();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_CACHE_TIME_END>---*/
}

double CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_cache_total_v1(void* thisClassHdl,
                                                                            KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_CACHE_TOTAL>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0.0;

  return stream->m_stream->GetCacheTotal();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_CACHE_TOTAL_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_pause_v1(void* thisClassHdl, KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_PAUSE>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->Pause();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_PAUSE_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_resume_v1(void* thisClassHdl,
                                                                 KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_RESUME>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->Resume();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_RESUME_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_drain_v1(void* thisClassHdl,
                                                                KODI_AE_HDL hdl,
                                                                bool wait)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_DRAIN>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->Drain(wait);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_DRAIN_END>---*/
}

bool CHdl_kodi_audio_engine_h::kodi_audioengine_stream_is_draining_v1(void* thisClassHdl,
                                                                      KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_IS_DRAINING>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return false;

  return stream->m_stream->IsDraining();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_IS_DRAINING_END>---*/
}

bool CHdl_kodi_audio_engine_h::kodi_audioengine_stream_is_drained_v1(void* thisClassHdl,
                                                                     KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_IS_DRAINED>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return false;

  return stream->m_stream->IsDrained();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_IS_DRAINED_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_flush_v1(void* thisClassHdl, KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_FLUSH>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->Flush();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_FLUSH_END>---*/
}

float CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_volume_v1(void* thisClassHdl,
                                                                      KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0f;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_VOLUME>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0.0f;

  return stream->m_stream->GetVolume();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_VOLUME_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_set_volume_v1(void* thisClassHdl,
                                                                     KODI_AE_HDL hdl,
                                                                     float volume)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_SET_VOLUME>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->SetVolume(volume);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_SET_VOLUME_END>---*/
}

float CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_amplification_v1(void* thisClassHdl,
                                                                             KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0f;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_AMPLIFICATION>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0.0f;

  return stream->m_stream->GetAmplification();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_AMPLIFICATION_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_set_amplification_v1(void* thisClassHdl,
                                                                            KODI_AE_HDL hdl,
                                                                            float amplify)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_SET_AMPLIFICATION>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->SetAmplification(amplify);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_SET_AMPLIFICATION_END>---*/
}

unsigned int CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_frame_size_v1(void* thisClassHdl,
                                                                                 KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_FRAME_SIZE>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0;

  return stream->m_stream->GetFrameSize();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_FRAME_SIZE_END>---*/
}

unsigned int CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_channel_count_v1(
    void* thisClassHdl, KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_CHANNEL_COUNT>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0;

  return stream->m_stream->GetChannelCount();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_CHANNEL_COUNT_END>---*/
}

unsigned int CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_sample_rate_v1(
    void* thisClassHdl, KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_SAMPLE_RATE>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0;

  return stream->m_stream->GetSampleRate();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_SAMPLE_RATE_END>---*/
}

enum AudioEngineDataFormat CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_data_format_v1(
    void* thisClassHdl, KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return AUDIOENGINE_FMT_INVALID;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_DATA_FORMAT>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return AudioEngineDataFormat::AUDIOENGINE_FMT_INVALID;

  return TranslateAEFormatToAddon(stream->m_stream->GetDataFormat());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_DATA_FORMAT_END>---*/
}

double CHdl_kodi_audio_engine_h::kodi_audioengine_stream_get_resample_ratio_v1(void* thisClassHdl,
                                                                               KODI_AE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_RESAMPLE_RATIO>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return 0.0;

  return stream->m_stream->GetResampleRatio();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_GET_RESAMPLE_RATIO_END>---*/
}

void CHdl_kodi_audio_engine_h::kodi_audioengine_stream_set_resample_ratio_v1(void* thisClassHdl,
                                                                             KODI_AE_HDL hdl,
                                                                             double ratio)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_audio_engine_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_SET_RESAMPLE_RATIO>---*/

  CAddonAudioStream* stream = static_cast<CAddonAudioStream*>(hdl);
  if (!stream || !stream->m_stream)
    return;

  stream->m_stream->SetResampleRatio(ratio);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_AUDIOENGINE_STREAM_SET_RESAMPLE_RATIO_END>---*/
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

} /* namespace INTERFACE */
} /* namespace ADDONS */
} /* namespace KODI */
