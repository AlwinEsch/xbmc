/*
 *  Copyright (C) 2005-2021 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "filesystem.h"

// Shared API
#include "addons/kodi-dev-kit/src/shared/api/filesystem.h"

// Kodi
#include "addons/interface/RunningProcess.h"
#include "utils/log.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/

#include "FileItem.h"
#include "Util.h"
#include "addons/interface/RunningProcess.h"
#include "filesystem/CurlFile.h"
#include "filesystem/Directory.h"
#include "filesystem/File.h"
#include "filesystem/SpecialProtocol.h"
#include "platform/Filesystem.h"
#include "utils/Crc32.h"
#include "utils/HttpHeader.h"
#include "utils/StringUtils.h"
#include "utils/URIUtils.h"

#if defined(TARGET_WINDOWS)
#ifndef S_IFLNK
#define S_IFLNK 0120000
#endif
#ifndef S_ISBLK
#define S_ISBLK(m) (0)
#endif
#ifndef S_ISSOCK
#define S_ISSOCK(m) (0)
#endif
#ifndef S_ISLNK
#define S_ISLNK(m) ((m & S_IFLNK) != 0)
#endif
#ifndef S_ISCHR
#define S_ISCHR(m) ((m & _S_IFCHR) != 0)
#endif
#ifndef S_ISDIR
#define S_ISDIR(m) ((m & _S_IFDIR) != 0)
#endif
#ifndef S_ISFIFO
#define S_ISFIFO(m) ((m & _S_IFIFO) != 0)
#endif
#ifndef S_ISREG
#define S_ISREG(m) ((m & _S_IFREG) != 0)
#endif
#endif

using namespace XFILE;

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

namespace KODI
{
namespace ADDONS
{
namespace INTERFACE
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/

namespace
{

unsigned int TranslateFileReadBitsToKodi(unsigned int addonFlags)
{
  unsigned int kodiFlags = 0;

  if (addonFlags & ADDON_READ_TRUNCATED)
    kodiFlags |= READ_TRUNCATED;
  if (addonFlags & ADDON_READ_CHUNKED)
    kodiFlags |= READ_CHUNKED;
  if (addonFlags & ADDON_READ_CACHED)
    kodiFlags |= READ_CACHED;
  if (addonFlags & ADDON_READ_NO_CACHE)
    kodiFlags |= READ_NO_CACHE;
  if (addonFlags & ADDON_READ_BITRATE)
    kodiFlags |= READ_BITRATE;
  if (addonFlags & ADDON_READ_MULTI_STREAM)
    kodiFlags |= READ_MULTI_STREAM;
  if (addonFlags & ADDON_READ_AUDIO_VIDEO)
    kodiFlags |= READ_AUDIO_VIDEO;
  if (addonFlags & ADDON_READ_AFTER_WRITE)
    kodiFlags |= READ_AFTER_WRITE;
  if (addonFlags & READ_REOPEN)
    kodiFlags |= READ_REOPEN;

  return kodiFlags;
}

XFILE::FileProperty TranslateFilePropertyToKodi(FilePropertyTypes type)
{
  XFILE::FileProperty internalType;
  switch (type)
  {
    case ADDON_FILE_PROPERTY_RESPONSE_PROTOCOL:
      internalType = XFILE::FILE_PROPERTY_RESPONSE_PROTOCOL;
      break;
    case ADDON_FILE_PROPERTY_RESPONSE_HEADER:
      internalType = XFILE::FILE_PROPERTY_RESPONSE_HEADER;
      break;
    case ADDON_FILE_PROPERTY_CONTENT_TYPE:
      internalType = XFILE::FILE_PROPERTY_CONTENT_TYPE;
      break;
    case ADDON_FILE_PROPERTY_CONTENT_CHARSET:
      internalType = XFILE::FILE_PROPERTY_CONTENT_CHARSET;
      break;
    case ADDON_FILE_PROPERTY_MIME_TYPE:
      internalType = XFILE::FILE_PROPERTY_MIME_TYPE;
      break;
    case ADDON_FILE_PROPERTY_EFFECTIVE_URL:
      internalType = XFILE::FILE_PROPERTY_EFFECTIVE_URL;
      break;
    default:
      CLog::Log(LOGERROR, "{} - invalid type", __func__);
      internalType = XFILE::FILE_PROPERTY_RESPONSE_PROTOCOL;
      break;
  };

  return internalType;
}

static void CFileItemListToVFSDirEntries(VFS_DIR_ENTRY* entries, const CFileItemList& items)
{
  for (unsigned int i = 0; i < static_cast<unsigned int>(items.Size()); ++i)
  {
    entries[i].label = strdup(items[i]->GetLabel().c_str());
    entries[i].path = strdup(items[i]->GetPath().c_str());
    entries[i].size = items[i]->m_dwSize;
    entries[i].folder = items[i]->m_bIsFolder;
    items[i]->m_dateTime.GetAsTime(entries[i].date_time);
  }
}

/*
 * CHttpHeader to use on addons, used with IInterfaceClassHdl to know opened parts
 * in case of addon crash or wrong exits.
 */
class CAddonHttpHeader : public IInterfaceClassHdl, public CHttpHeader
{
public:
  CAddonHttpHeader() : IInterfaceClassHdl(InterfaceKodiClass::CHttpHeader) {}
};

/*
 * CFile to use on addons, used with IInterfaceClassHdl to know opened parts
 * in case of addon crash or wrong exits.
 */
class CAddonFile : public IInterfaceClassHdl, public CFile
{
public:
  CAddonFile() : IInterfaceClassHdl(InterfaceKodiClass::CFile) {}
};

} /* namespace */

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_filesystem_h::InitDirect(directFuncToKodi_filesystem_h* ifcToKodi,
                                        directFuncToAddon_filesystem_h* ifcToAddon)
{
  ifcToKodi->thisClassHdl = this;
  m_ifcToAddon = ifcToAddon;
  ifcToKodi->kodi_vfs_can_open_directory_v1 = kodi_vfs_can_open_directory_v1;
  ifcToKodi->kodi_vfs_create_directory_v1 = kodi_vfs_create_directory_v1;
  ifcToKodi->kodi_vfs_remove_directory_v1 = kodi_vfs_remove_directory_v1;
  ifcToKodi->kodi_vfs_remove_directory_recursive_v1 = kodi_vfs_remove_directory_recursive_v1;
  ifcToKodi->kodi_vfs_directory_exists_v1 = kodi_vfs_directory_exists_v1;
  ifcToKodi->kodi_vfs_get_directory_v1 = kodi_vfs_get_directory_v1;
  // Unused "kodi_vfs_free_directory", done only in addon lib
  ifcToKodi->kodi_vfs_file_exists_v1 = kodi_vfs_file_exists_v1;
  ifcToKodi->kodi_vfs_stat_file_v1 = kodi_vfs_stat_file_v1;
  ifcToKodi->kodi_vfs_delete_file_v1 = kodi_vfs_delete_file_v1;
  ifcToKodi->kodi_vfs_rename_file_v1 = kodi_vfs_rename_file_v1;
  ifcToKodi->kodi_vfs_copy_file_v1 = kodi_vfs_copy_file_v1;
  ifcToKodi->kodi_vfs_get_file_md5_v1 = kodi_vfs_get_file_md5_v1;
  ifcToKodi->kodi_vfs_get_cache_thumb_name_v1 = kodi_vfs_get_cache_thumb_name_v1;
  ifcToKodi->kodi_vfs_make_legal_filename_v1 = kodi_vfs_make_legal_filename_v1;
  ifcToKodi->kodi_vfs_make_legal_path_v1 = kodi_vfs_make_legal_path_v1;
  ifcToKodi->kodi_vfs_translate_special_protocol_v1 = kodi_vfs_translate_special_protocol_v1;
  ifcToKodi->kodi_vfs_is_internet_stream_v1 = kodi_vfs_is_internet_stream_v1;
  ifcToKodi->kodi_vfs_is_on_lan_v1 = kodi_vfs_is_on_lan_v1;
  ifcToKodi->kodi_vfs_is_remote_v1 = kodi_vfs_is_remote_v1;
  ifcToKodi->kodi_vfs_is_local_v1 = kodi_vfs_is_local_v1;
  ifcToKodi->kodi_vfs_is_url_v1 = kodi_vfs_is_url_v1;
  ifcToKodi->kodi_vfs_get_mime_type_v1 = kodi_vfs_get_mime_type_v1;
  ifcToKodi->kodi_vfs_get_content_type_v1 = kodi_vfs_get_content_type_v1;
  ifcToKodi->kodi_vfs_get_cookies_v1 = kodi_vfs_get_cookies_v1;
  ifcToKodi->kodi_vfs_get_disk_space_v1 = kodi_vfs_get_disk_space_v1;
  ifcToKodi->kodi_vfs_http_header_open_v1 = kodi_vfs_http_header_open_v1;
  ifcToKodi->kodi_vfs_http_header_close_v1 = kodi_vfs_http_header_close_v1;
  ifcToKodi->kodi_vfs_http_header_get_value_v1 = kodi_vfs_http_header_get_value_v1;
  ifcToKodi->kodi_vfs_http_header_get_values_v1 = kodi_vfs_http_header_get_values_v1;
  ifcToKodi->kodi_vfs_http_header_get_header_v1 = kodi_vfs_http_header_get_header_v1;
  ifcToKodi->kodi_vfs_http_header_get_mime_type_v1 = kodi_vfs_http_header_get_mime_type_v1;
  ifcToKodi->kodi_vfs_http_header_get_charset_v1 = kodi_vfs_http_header_get_charset_v1;
  ifcToKodi->kodi_vfs_http_header_get_proto_line_v1 = kodi_vfs_http_header_get_proto_line_v1;
  ifcToKodi->kodi_vfs_file_open_v1 = kodi_vfs_file_open_v1;
  ifcToKodi->kodi_vfs_file_open_for_write_v1 = kodi_vfs_file_open_for_write_v1;
  ifcToKodi->kodi_vfs_file_curl_create_v1 = kodi_vfs_file_curl_create_v1;
  ifcToKodi->kodi_vfs_file_curl_add_option_v1 = kodi_vfs_file_curl_add_option_v1;
  ifcToKodi->kodi_vfs_file_curl_open_v1 = kodi_vfs_file_curl_open_v1;
  ifcToKodi->kodi_vfs_file_close_v1 = kodi_vfs_file_close_v1;
  ifcToKodi->kodi_vfs_file_read_v1 = kodi_vfs_file_read_v1;
  ifcToKodi->kodi_vfs_file_read_line_v1 = kodi_vfs_file_read_line_v1;
  ifcToKodi->kodi_vfs_file_write_v1 = kodi_vfs_file_write_v1;
  ifcToKodi->kodi_vfs_file_flush_v1 = kodi_vfs_file_flush_v1;
  ifcToKodi->kodi_vfs_file_seek_v1 = kodi_vfs_file_seek_v1;
  ifcToKodi->kodi_vfs_file_truncate_v1 = kodi_vfs_file_truncate_v1;
  ifcToKodi->kodi_vfs_file_get_position_v1 = kodi_vfs_file_get_position_v1;
  ifcToKodi->kodi_vfs_file_get_length_v1 = kodi_vfs_file_get_length_v1;
  ifcToKodi->kodi_vfs_file_at_end_v1 = kodi_vfs_file_at_end_v1;
  ifcToKodi->kodi_vfs_file_get_download_speed_v1 = kodi_vfs_file_get_download_speed_v1;
  ifcToKodi->kodi_vfs_file_get_chunk_size_v1 = kodi_vfs_file_get_chunk_size_v1;
  ifcToKodi->kodi_vfs_file_io_ctl_get_seek_possible_v1 = kodi_vfs_file_io_ctl_get_seek_possible_v1;
  ifcToKodi->kodi_vfs_file_io_ctl_get_cache_status_v1 = kodi_vfs_file_io_ctl_get_cache_status_v1;
  ifcToKodi->kodi_vfs_file_io_ctl_set_cache_rate_v1 = kodi_vfs_file_io_ctl_set_cache_rate_v1;
  ifcToKodi->kodi_vfs_file_io_ctl_set_retry_v1 = kodi_vfs_file_io_ctl_set_retry_v1;
  ifcToKodi->kodi_vfs_file_get_property_value_v1 = kodi_vfs_file_get_property_value_v1;
  ifcToKodi->kodi_vfs_file_get_property_values_v1 = kodi_vfs_file_get_property_values_v1;
}

bool CHdl_kodi_filesystem_h::HandleMessage(int funcGroup,
                                           int func,
                                           const msgpack::unpacked& in,
                                           msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_filesystem_h)
    return false;

  switch (func)
  {
    case funcParent_kodi_vfs_can_open_directory_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_can_open_directory(const char* url) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_can_open_directory_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_can_open_directory_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_can_open_directory_v1 t = in.get().as<decltype(t)>();
      const std::string& url = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_can_open_directory_v1(this, url.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_can_open_directory_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_create_directory_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_create_directory(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_create_directory_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_create_directory_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_create_directory_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_create_directory_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_create_directory_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_remove_directory_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_remove_directory(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_remove_directory_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_remove_directory_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_remove_directory_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_remove_directory_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_remove_directory_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_remove_directory_recursive_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_remove_directory_recursive(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_remove_directory_recursive_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_remove_directory_recursive_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_remove_directory_recursive_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_remove_directory_recursive_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_remove_directory_recursive_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_directory_exists_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_directory_exists(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_directory_exists_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_directory_exists_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_directory_exists_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_directory_exists_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_directory_exists_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_get_directory_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_directory(const char* path, const char* mask, struct VFS_DIR_ENTRY** items, size_t* num_items) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, std::string, size_t> msgParent__IN_kodi_vfs_get_directory_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::vector<IFC_VFS_DIR_ENTRY>, size_t> msgParent_OUT_kodi_vfs_get_directory_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_directory_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      const std::string& mask = std::get<1>(t);
      struct VFS_DIR_ENTRY* items = nullptr;
      size_t num_items = std::get<2>(t);
      bool auto_gen_ret =
          kodi_vfs_get_directory_v1(this, path.c_str(), mask.c_str(), &items, &num_items);
      std::vector<IFC_VFS_DIR_ENTRY> ifc_items;
      if (items)
      {
        ifc_items.reserve(num_items);
        for (size_t i = 0; i < num_items; ++i)
        {
          ifc_items.emplace_back(&items[i]);
          ifc_items[i].CleanCStructure(&items[i]);
        }
        free(items);
      }
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_get_directory_v1(auto_gen_ret, ifc_items, num_items));
      return true;
    }
    case funcParent_kodi_vfs_file_exists_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_exists(const char* filename, bool useCache) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_vfs_file_exists_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_exists_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_exists_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      bool useCache = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_file_exists_v1(this, filename.c_str(), useCache);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_exists_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_stat_file_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_stat_file(const char* filename, struct VFS_STAT_STRUCTURE* buffer) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_stat_file_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, IFC_VFS_STAT_STRUCTURE> msgParent_OUT_kodi_vfs_stat_file_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_stat_file_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      struct VFS_STAT_STRUCTURE buffer;
      bool auto_gen_ret = kodi_vfs_stat_file_v1(this, filename.c_str(), &buffer);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_stat_file_v1(auto_gen_ret, &buffer));
      return true;
    }
    case funcParent_kodi_vfs_delete_file_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_delete_file(const char* filename) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_delete_file_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_delete_file_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_delete_file_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_delete_file_v1(this, filename.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_delete_file_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_rename_file_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_rename_file(const char* filename, const char* newFileName) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_rename_file_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_rename_file_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_rename_file_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      const std::string& newFileName = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_rename_file_v1(this, filename.c_str(), newFileName.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_rename_file_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_copy_file_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_copy_file(const char* filename, const char* dest) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_copy_file_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_copy_file_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_copy_file_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      const std::string& dest = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_copy_file_v1(this, filename.c_str(), dest.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_copy_file_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_get_file_md5_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_get_file_md5(const char* filename) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_get_file_md5_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_get_file_md5_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_file_md5_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      char* auto_gen_ret = kodi_vfs_get_file_md5_v1(this, filename.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_get_file_md5_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_get_cache_thumb_name_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_get_cache_thumb_name(const char* filename) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_get_cache_thumb_name_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_get_cache_thumb_name_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_cache_thumb_name_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      char* auto_gen_ret = kodi_vfs_get_cache_thumb_name_v1(this, filename.c_str());
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_get_cache_thumb_name_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_make_legal_filename_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_make_legal_filename(const char* filename) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_make_legal_filename_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_make_legal_filename_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_make_legal_filename_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      char* auto_gen_ret = kodi_vfs_make_legal_filename_v1(this, filename.c_str());
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_make_legal_filename_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_make_legal_path_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_make_legal_path(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_make_legal_path_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_make_legal_path_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_make_legal_path_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      char* auto_gen_ret = kodi_vfs_make_legal_path_v1(this, path.c_str());
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_make_legal_path_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_translate_special_protocol_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_translate_special_protocol(const char* strSource) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_translate_special_protocol_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_translate_special_protocol_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_translate_special_protocol_v1 t = in.get().as<decltype(t)>();
      const std::string& strSource = std::get<0>(t);
      char* auto_gen_ret = kodi_vfs_translate_special_protocol_v1(this, strSource.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_translate_special_protocol_v1(
                             auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_is_internet_stream_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_internet_stream(const char* path, bool strictCheck) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_vfs_is_internet_stream_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_internet_stream_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_is_internet_stream_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool strictCheck = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_is_internet_stream_v1(this, path.c_str(), strictCheck);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_is_internet_stream_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_is_on_lan_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_on_lan(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_on_lan_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_on_lan_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_is_on_lan_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_is_on_lan_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_is_on_lan_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_is_remote_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_remote(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_remote_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_remote_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_is_remote_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_is_remote_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_is_remote_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_is_local_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_local(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_local_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_local_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_is_local_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_is_local_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_is_local_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_is_url_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_url(const char* path) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_url_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_url_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_is_url_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      bool auto_gen_ret = kodi_vfs_is_url_v1(this, path.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_is_url_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_get_mime_type_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_mime_type(const char* url, char** content, const char* useragent) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_get_mime_type_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_get_mime_type_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_mime_type_v1 t = in.get().as<decltype(t)>();
      const std::string& url = std::get<0>(t);
      char* content = nullptr;
      const std::string& useragent = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_get_mime_type_v1(this, url.c_str(), &content, useragent.c_str());
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_get_mime_type_v1(auto_gen_ret, content ? content : ""));
      if (content)
        free(content);
      return true;
    }
    case funcParent_kodi_vfs_get_content_type_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_content_type(const char* url, char** content, const char* useragent) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_get_content_type_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_get_content_type_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_content_type_v1 t = in.get().as<decltype(t)>();
      const std::string& url = std::get<0>(t);
      char* content = nullptr;
      const std::string& useragent = std::get<1>(t);
      bool auto_gen_ret =
          kodi_vfs_get_content_type_v1(this, url.c_str(), &content, useragent.c_str());
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_get_content_type_v1(auto_gen_ret, content ? content : ""));
      if (content)
        free(content);
      return true;
    }
    case funcParent_kodi_vfs_get_cookies_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_cookies(const char* url, char** cookies) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_get_cookies_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_get_cookies_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_cookies_v1 t = in.get().as<decltype(t)>();
      const std::string& url = std::get<0>(t);
      char* cookies = nullptr;
      bool auto_gen_ret = kodi_vfs_get_cookies_v1(this, url.c_str(), &cookies);
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_get_cookies_v1(auto_gen_ret, cookies ? cookies : ""));
      if (cookies)
        free(cookies);
      return true;
    }
    case funcParent_kodi_vfs_get_disk_space_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_disk_space(const char* path, uint64_t* capacity, uint64_t* free, uint64_t* available) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, uint64_t, uint64_t, uint64_t> msgParent__IN_kodi_vfs_get_disk_space_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, uint64_t, uint64_t, uint64_t> msgParent_OUT_kodi_vfs_get_disk_space_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_get_disk_space_v1 t = in.get().as<decltype(t)>();
      const std::string& path = std::get<0>(t);
      uint64_t capacity = std::get<1>(t);
      uint64_t free = std::get<2>(t);
      uint64_t available = std::get<3>(t);
      bool auto_gen_ret =
          kodi_vfs_get_disk_space_v1(this, path.c_str(), &capacity, &free, &available);
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_get_disk_space_v1(auto_gen_ret, capacity, free, available));
      return true;
    }
    case funcParent_kodi_vfs_http_header_open_v1:
    {
      // Original API call: ATTR_DLL_EXPORT KODI_HTTP_HEADER_HDL kodi_vfs_http_header_open(const char* url) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_http_header_open_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_http_header_open_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_open_v1 t = in.get().as<decltype(t)>();
      const std::string& url = std::get<0>(t);
      KODI_HTTP_HEADER_HDL auto_gen_ret = kodi_vfs_http_header_open_v1(this, url.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_http_header_open_v1(PtrValue(auto_gen_ret)));
      return true;
    }
    case funcParent_kodi_vfs_http_header_close_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_vfs_http_header_close(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_close_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_vfs_http_header_close_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_close_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      kodi_vfs_http_header_close_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_vfs_http_header_get_value_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_value(KODI_HTTP_HEADER_HDL hdl, const char* param) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string> msgParent__IN_kodi_vfs_http_header_get_value_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_value_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_get_value_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      const std::string& param = std::get<1>(t);
      char* auto_gen_ret = kodi_vfs_http_header_get_value_v1(this, hdl, param.c_str());
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_http_header_get_value_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_http_header_get_values_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char** kodi_vfs_http_header_get_values(KODI_HTTP_HEADER_HDL hdl, const char* param, size_t* length) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, size_t> msgParent__IN_kodi_vfs_http_header_get_values_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::vector<std::string>, size_t> msgParent_OUT_kodi_vfs_http_header_get_values_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_get_values_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      const std::string& param = std::get<1>(t);
      size_t length = std::get<2>(t);
      char** auto_gen_ret = kodi_vfs_http_header_get_values_v1(this, hdl, param.c_str(), &length);
      std::vector<std::string> auto_gen_ret_cpp;
      if (auto_gen_ret)
      {
        auto_gen_ret_cpp.reserve(length);
        for (size_t i = 0; i < length; ++i)
        {
          if (auto_gen_ret[i])
          {
            auto_gen_ret_cpp.emplace_back(auto_gen_ret[i]);
            free(auto_gen_ret[i]);
          }
        }
        free(auto_gen_ret);
      }
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_http_header_get_values_v1(auto_gen_ret_cpp, length));
      return true;
    }
    case funcParent_kodi_vfs_http_header_get_header_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_header(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_header_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_header_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_get_header_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      char* auto_gen_ret = kodi_vfs_http_header_get_header_v1(this, hdl);
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_http_header_get_header_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_http_header_get_mime_type_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_mime_type(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_mime_type_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_mime_type_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_get_mime_type_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      char* auto_gen_ret = kodi_vfs_http_header_get_mime_type_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_http_header_get_mime_type_v1(
                             auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_http_header_get_charset_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_charset(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_charset_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_charset_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_get_charset_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      char* auto_gen_ret = kodi_vfs_http_header_get_charset_v1(this, hdl);
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_http_header_get_charset_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_http_header_get_proto_line_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_proto_line(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_proto_line_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_proto_line_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_http_header_get_proto_line_v1 t = in.get().as<decltype(t)>();
      KODI_HTTP_HEADER_HDL hdl = reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
      char* auto_gen_ret = kodi_vfs_http_header_get_proto_line_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_http_header_get_proto_line_v1(
                             auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_file_open_v1:
    {
      // Original API call: ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_open(const char* filename, unsigned int flags) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, unsigned int> msgParent__IN_kodi_vfs_file_open_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_file_open_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_open_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      unsigned int flags = std::get<1>(t);
      KODI_FILE_HDL auto_gen_ret = kodi_vfs_file_open_v1(this, filename.c_str(), flags);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_open_v1(PtrValue(auto_gen_ret)));
      return true;
    }
    case funcParent_kodi_vfs_file_open_for_write_v1:
    {
      // Original API call: ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_open_for_write(const char* filename, bool overwrite) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_vfs_file_open_for_write_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_file_open_for_write_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_open_for_write_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      bool overwrite = std::get<1>(t);
      KODI_FILE_HDL auto_gen_ret =
          kodi_vfs_file_open_for_write_v1(this, filename.c_str(), overwrite);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_open_for_write_v1(PtrValue(auto_gen_ret)));
      return true;
    }
    case funcParent_kodi_vfs_file_curl_create_v1:
    {
      // Original API call: ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_curl_create(const char* url) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_file_curl_create_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_file_curl_create_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_curl_create_v1 t = in.get().as<decltype(t)>();
      const std::string& url = std::get<0>(t);
      KODI_FILE_HDL auto_gen_ret = kodi_vfs_file_curl_create_v1(this, url.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_curl_create_v1(PtrValue(auto_gen_ret)));
      return true;
    }
    case funcParent_kodi_vfs_file_curl_add_option_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_curl_add_option(KODI_FILE_HDL hdl, enum CURLOptiontype type, const char* name, const char* value) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, CURLOptiontype, std::string, std::string> msgParent__IN_kodi_vfs_file_curl_add_option_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_curl_add_option_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_curl_add_option_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      enum CURLOptiontype type = std::get<1>(t);
      const std::string& name = std::get<2>(t);
      const std::string& value = std::get<3>(t);
      bool auto_gen_ret =
          kodi_vfs_file_curl_add_option_v1(this, hdl, type, name.c_str(), value.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_curl_add_option_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_curl_open_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_curl_open(KODI_FILE_HDL hdl, unsigned int flags) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, unsigned int> msgParent__IN_kodi_vfs_file_curl_open_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_curl_open_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_curl_open_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      unsigned int flags = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_file_curl_open_v1(this, hdl, flags);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_curl_open_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_close_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_vfs_file_close(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_close_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_vfs_file_close_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_close_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      kodi_vfs_file_close_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_vfs_file_read_v1:
    {
      // Original API call: ATTR_DLL_EXPORT ssize_t kodi_vfs_file_read(KODI_FILE_HDL hdl, uint8_t* ptr, size_t size) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, size_t> msgParent__IN_kodi_vfs_file_read_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ssize_t, std::vector<uint8_t>> msgParent_OUT_kodi_vfs_file_read_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_read_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));

      size_t size = std::get<1>(t);
      std::vector<uint8_t> ptr(size);
      ssize_t auto_gen_ret = kodi_vfs_file_read_v1(this, hdl, ptr.data(), size);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_read_v1(auto_gen_ret, ptr));
      return true;
    }
    case funcParent_kodi_vfs_file_read_line_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_read_line(KODI_FILE_HDL hdl, char* szLine, size_t lineLength) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, size_t> msgParent__IN_kodi_vfs_file_read_line_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_file_read_line_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_read_line_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      std::string szLine;
      size_t lineLength = std::get<1>(t);
      szLine.reserve(lineLength);
      bool auto_gen_ret = kodi_vfs_file_read_line_v1(this, hdl, &szLine[0], lineLength);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_read_line_v1(auto_gen_ret, szLine));
      return true;
    }
    case funcParent_kodi_vfs_file_write_v1:
    {
      // Original API call: ATTR_DLL_EXPORT ssize_t kodi_vfs_file_write(KODI_FILE_HDL hdl, const uint8_t* ptr, size_t size) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, std::vector<uint8_t>, size_t> msgParent__IN_kodi_vfs_file_write_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ssize_t> msgParent_OUT_kodi_vfs_file_write_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_write_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      const std::vector<uint8_t>& ptr = std::get<1>(t);
      size_t size = std::get<2>(t);
      ssize_t auto_gen_ret = kodi_vfs_file_write_v1(this, hdl, ptr.data(), size);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_write_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_flush_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_vfs_file_flush(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_flush_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_vfs_file_flush_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_flush_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      kodi_vfs_file_flush_v1(this, hdl);
      return true;
    }
    case funcParent_kodi_vfs_file_seek_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int64_t kodi_vfs_file_seek(KODI_FILE_HDL hdl, int64_t position, int whence) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, int64_t, int> msgParent__IN_kodi_vfs_file_seek_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int64_t> msgParent_OUT_kodi_vfs_file_seek_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_seek_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      int64_t position = std::get<1>(t);
      int whence = std::get<2>(t);
      int64_t auto_gen_ret = kodi_vfs_file_seek_v1(this, hdl, position, whence);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_seek_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_truncate_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int kodi_vfs_file_truncate(KODI_FILE_HDL hdl, int64_t size) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, int64_t> msgParent__IN_kodi_vfs_file_truncate_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_vfs_file_truncate_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_truncate_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      int64_t size = std::get<1>(t);
      int auto_gen_ret = kodi_vfs_file_truncate_v1(this, hdl, size);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_truncate_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_get_position_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int64_t kodi_vfs_file_get_position(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_position_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int64_t> msgParent_OUT_kodi_vfs_file_get_position_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_get_position_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      int64_t auto_gen_ret = kodi_vfs_file_get_position_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_get_position_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_get_length_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int64_t kodi_vfs_file_get_length(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_length_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int64_t> msgParent_OUT_kodi_vfs_file_get_length_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_get_length_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      int64_t auto_gen_ret = kodi_vfs_file_get_length_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_get_length_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_at_end_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_at_end(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_at_end_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_at_end_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_at_end_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      bool auto_gen_ret = kodi_vfs_file_at_end_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_at_end_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_get_download_speed_v1:
    {
      // Original API call: ATTR_DLL_EXPORT double kodi_vfs_file_get_download_speed(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_download_speed_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<double> msgParent_OUT_kodi_vfs_file_get_download_speed_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_get_download_speed_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      double auto_gen_ret = kodi_vfs_file_get_download_speed_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_get_download_speed_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_get_chunk_size_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int kodi_vfs_file_get_chunk_size(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_chunk_size_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_vfs_file_get_chunk_size_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_get_chunk_size_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      int auto_gen_ret = kodi_vfs_file_get_chunk_size_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_get_chunk_size_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_io_ctl_get_seek_possible_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_get_seek_possible(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_io_ctl_get_seek_possible_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_io_ctl_get_seek_possible_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_io_ctl_get_seek_possible_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      bool auto_gen_ret = kodi_vfs_file_io_ctl_get_seek_possible_v1(this, hdl);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_io_ctl_get_seek_possible_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_io_ctl_get_cache_status_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_get_cache_status(KODI_FILE_HDL hdl, struct VFS_CACHE_STATUS* status) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_io_ctl_get_cache_status_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, IFC_VFS_CACHE_STATUS> msgParent_OUT_kodi_vfs_file_io_ctl_get_cache_status_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_io_ctl_get_cache_status_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      struct VFS_CACHE_STATUS status;
      bool auto_gen_ret = kodi_vfs_file_io_ctl_get_cache_status_v1(this, hdl, &status);
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_file_io_ctl_get_cache_status_v1(auto_gen_ret, &status));
      return true;
    }
    case funcParent_kodi_vfs_file_io_ctl_set_cache_rate_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_set_cache_rate(KODI_FILE_HDL hdl, unsigned int rate) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, unsigned int> msgParent__IN_kodi_vfs_file_io_ctl_set_cache_rate_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_io_ctl_set_cache_rate_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_io_ctl_set_cache_rate_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      unsigned int rate = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_file_io_ctl_set_cache_rate_v1(this, hdl, rate);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_io_ctl_set_cache_rate_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_io_ctl_set_retry_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_set_retry(KODI_FILE_HDL hdl, bool retry) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, bool> msgParent__IN_kodi_vfs_file_io_ctl_set_retry_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_io_ctl_set_retry_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_io_ctl_set_retry_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      bool retry = std::get<1>(t);
      bool auto_gen_ret = kodi_vfs_file_io_ctl_set_retry_v1(this, hdl, retry);
      msgpack::pack(out, msgParent_OUT_kodi_vfs_file_io_ctl_set_retry_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_vfs_file_get_property_value_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_file_get_property_value(KODI_FILE_HDL hdl, enum FilePropertyTypes type, const char* name) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, FilePropertyTypes, std::string> msgParent__IN_kodi_vfs_file_get_property_value_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_file_get_property_value_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_get_property_value_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      enum FilePropertyTypes type = std::get<1>(t);
      const std::string& name = std::get<2>(t);
      char* auto_gen_ret = kodi_vfs_file_get_property_value_v1(this, hdl, type, name.c_str());
      msgpack::pack(
          out, msgParent_OUT_kodi_vfs_file_get_property_value_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_vfs_file_get_property_values_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char** kodi_vfs_file_get_property_values(KODI_FILE_HDL hdl, enum FilePropertyTypes type, const char* name, size_t* length) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<PtrValue, FilePropertyTypes, std::string, size_t> msgParent__IN_kodi_vfs_file_get_property_values_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::vector<std::string>, size_t> msgParent_OUT_kodi_vfs_file_get_property_values_v1; /* Autogenerated */
      msgParent__IN_kodi_vfs_file_get_property_values_v1 t = in.get().as<decltype(t)>();
      KODI_FILE_HDL hdl = reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
      enum FilePropertyTypes type = std::get<1>(t);
      const std::string& name = std::get<2>(t);
      size_t length = std::get<3>(t);
      char** auto_gen_ret =
          kodi_vfs_file_get_property_values_v1(this, hdl, type, name.c_str(), &length);
      std::vector<std::string> auto_gen_ret_cpp;
      if (auto_gen_ret)
      {
        auto_gen_ret_cpp.reserve(length);
        for (size_t i = 0; i < length; ++i)
        {
          if (auto_gen_ret[i])
          {
            auto_gen_ret_cpp.emplace_back(auto_gen_ret[i]);
            free(auto_gen_ret[i]);
          }
        }
        free(auto_gen_ret);
      }
      msgpack::pack(out,
                    msgParent_OUT_kodi_vfs_file_get_property_values_v1(auto_gen_ret_cpp, length));
      return true;
    }
    default:
      CLog::Log(LOGERROR,
                "CHdl_kodi_filesystem_h::{}: addon called with unknown function id '{}' on group "
                "'filesystem_h'",
                __func__, func);
  }

  return false;
}

// Function calls from Kodi to addon
/* NOTE: unused (no functions here) */

// Callbacks from addon to Kodi

bool CHdl_kodi_filesystem_h::kodi_vfs_can_open_directory_v1(void* thisClassHdl, const char* url)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_CAN_OPEN_DIRECTORY>---*/

  CFileItemList items;
  return CDirectory::GetDirectory(url, items, "", DIR_FLAG_DEFAULTS);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_CAN_OPEN_DIRECTORY_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_create_directory_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_CREATE_DIRECTORY>---*/

  return CDirectory::Create(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_CREATE_DIRECTORY_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_remove_directory_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_REMOVE_DIRECTORY>---*/

  return CDirectory::Remove(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_REMOVE_DIRECTORY_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_remove_directory_recursive_v1(void* thisClassHdl,
                                                                    const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_REMOVE_DIRECTORY_RECURSIVE>---*/

  return CDirectory::RemoveRecursive(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_REMOVE_DIRECTORY_RECURSIVE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_directory_exists_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_DIRECTORY_EXISTS>---*/

  return CDirectory::Exists(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_DIRECTORY_EXISTS_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_get_directory_v1(void* thisClassHdl,
                                                       const char* path,
                                                       const char* mask,
                                                       struct VFS_DIR_ENTRY** items,
                                                       size_t* num_items)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_DIRECTORY>---*/

  CFileItemList fileItems;
  if (!CDirectory::GetDirectory(path, fileItems, mask, DIR_FLAG_NO_FILE_DIRS))
    return false;

  if (fileItems.Size() > 0)
  {
    *num_items = static_cast<size_t>(fileItems.Size());
    *items = static_cast<VFS_DIR_ENTRY*>(malloc(sizeof(VFS_DIR_ENTRY) * fileItems.Size()));
    CFileItemListToVFSDirEntries(*items, fileItems);
  }
  else
  {
    *num_items = 0;
    *items = nullptr;
  }

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_DIRECTORY_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_exists_v1(void* thisClassHdl,
                                                     const char* filename,
                                                     bool useCache)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_EXISTS>---*/

  return CFile::Exists(filename, useCache);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_EXISTS_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_stat_file_v1(void* thisClassHdl,
                                                   const char* filename,
                                                   struct VFS_STAT_STRUCTURE* buffer)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_STAT_FILE>---*/

  struct __stat64 statBuffer;
  if (CFile::Stat(filename, &statBuffer) != 0)
    return false;

  buffer->deviceId = statBuffer.st_dev;
  buffer->fileSerialNumber = statBuffer.st_ino;
  buffer->size = statBuffer.st_size;
  buffer->accessTime = statBuffer.st_atime;
  buffer->modificationTime = statBuffer.st_mtime;
  buffer->statusTime = statBuffer.st_ctime;
  buffer->isDirectory = S_ISDIR(statBuffer.st_mode);
  buffer->isSymLink = S_ISLNK(statBuffer.st_mode);
  buffer->isBlock = S_ISBLK(statBuffer.st_mode);
  buffer->isCharacter = S_ISCHR(statBuffer.st_mode);
  buffer->isFifo = S_ISFIFO(statBuffer.st_mode);
  buffer->isRegular = S_ISREG(statBuffer.st_mode);
  buffer->isSocket = S_ISSOCK(statBuffer.st_mode);

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_STAT_FILE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_delete_file_v1(void* thisClassHdl, const char* filename)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_DELETE_FILE>---*/

  return CFile::Delete(filename);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_DELETE_FILE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_rename_file_v1(void* thisClassHdl,
                                                     const char* filename,
                                                     const char* newFileName)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_RENAME_FILE>---*/

  return CFile::Rename(filename, newFileName);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_RENAME_FILE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_copy_file_v1(void* thisClassHdl,
                                                   const char* filename,
                                                   const char* dest)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_COPY_FILE>---*/

  return CFile::Copy(filename, dest);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_COPY_FILE_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_get_file_md5_v1(void* thisClassHdl, const char* filename)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_FILE_MD5>---*/

  std::string string = CUtil::GetFileDigest(filename, KODI::UTILITY::CDigest::Type::MD5);
  char* buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_FILE_MD5_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_get_cache_thumb_name_v1(void* thisClassHdl,
                                                               const char* filename)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_CACHE_THUMB_NAME>---*/

  const auto crc = Crc32::ComputeFromLowerCase(filename);
  const auto hex = StringUtils::Format("%08x.tbn", crc);
  char* buffer = strdup(hex.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_CACHE_THUMB_NAME_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_make_legal_filename_v1(void* thisClassHdl,
                                                              const char* filename)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_MAKE_LEGAL_FILENAME>---*/

  std::string string = CUtil::MakeLegalFileName(filename);
  char* buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_MAKE_LEGAL_FILENAME_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_make_legal_path_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_MAKE_LEGAL_PATH>---*/

  std::string string = CUtil::MakeLegalPath(path);
  char* buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_MAKE_LEGAL_PATH_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_translate_special_protocol_v1(void* thisClassHdl,
                                                                     const char* strSource)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_TRANSLATE_SPECIAL_PROTOCOL>---*/

  return strdup(CSpecialProtocol::TranslatePath(strSource).c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_TRANSLATE_SPECIAL_PROTOCOL_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_is_internet_stream_v1(void* thisClassHdl,
                                                            const char* path,
                                                            bool strictCheck)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_INTERNET_STREAM>---*/

  return URIUtils::IsInternetStream(path, strictCheck);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_INTERNET_STREAM_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_is_on_lan_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_ON_LAN>---*/

  return URIUtils::IsOnLAN(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_ON_LAN_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_is_remote_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_REMOTE>---*/

  return URIUtils::IsRemote(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_REMOTE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_is_local_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_LOCAL>---*/

  return CURL(path).IsLocal();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_LOCAL_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_is_url_v1(void* thisClassHdl, const char* path)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_URL>---*/

  return URIUtils::IsURL(path);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_IS_URL_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_get_mime_type_v1(void* thisClassHdl,
                                                       const char* url,
                                                       char** content,
                                                       const char* useragent)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_MIME_TYPE>---*/

  std::string kodiContent;
  bool ret = XFILE::CCurlFile::GetMimeType(CURL(url), kodiContent, useragent);
  if (ret && !kodiContent.empty())
  {
    *content = strdup(kodiContent.c_str());
  }
  return ret;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_MIME_TYPE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_get_content_type_v1(void* thisClassHdl,
                                                          const char* url,
                                                          char** content,
                                                          const char* useragent)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_CONTENT_TYPE>---*/

  std::string kodiContent;
  bool ret = XFILE::CCurlFile::GetContentType(CURL(url), kodiContent, useragent);
  if (ret && !kodiContent.empty())
  {
    *content = strdup(kodiContent.c_str());
  }
  return ret;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_CONTENT_TYPE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_get_cookies_v1(void* thisClassHdl,
                                                     const char* url,
                                                     char** cookies)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_COOKIES>---*/

  std::string kodiCookies;
  bool ret = XFILE::CCurlFile::GetCookies(CURL(url), kodiCookies);
  if (ret && !kodiCookies.empty())
  {
    *cookies = strdup(kodiCookies.c_str());
  }
  return ret;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_COOKIES_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_get_disk_space_v1(
    void* thisClassHdl, const char* path, uint64_t* capacity, uint64_t* free, uint64_t* available)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_DISK_SPACE>---*/

  using namespace KODI::PLATFORM::FILESYSTEM;

  std::error_code ec;
  auto freeSpace = space(CSpecialProtocol::TranslatePath(path), ec);
  if (ec.value() != 0)
    return false;

  *capacity = freeSpace.capacity;
  *free = freeSpace.free;
  *available = freeSpace.available;
  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_GET_DISK_SPACE_END>---*/
}

KODI_HTTP_HEADER_HDL CHdl_kodi_filesystem_h::kodi_vfs_http_header_open_v1(void* thisClassHdl,
                                                                          const char* url)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_OPEN>---*/


  CAddonHttpHeader* httpHeader = new CAddonHttpHeader;
  if (!XFILE::CCurlFile::GetHttpHeader(CURL(url), *httpHeader))
  {
    delete httpHeader;
    return nullptr;
  }

  return static_cast<KODI_HTTP_HEADER_HDL>(httpHeader);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_OPEN_END>---*/
}

void CHdl_kodi_filesystem_h::kodi_vfs_http_header_close_v1(void* thisClassHdl,
                                                           KODI_HTTP_HEADER_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_CLOSE>---*/

  delete static_cast<CAddonHttpHeader*>(hdl);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_CLOSE_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_http_header_get_value_v1(void* thisClassHdl,
                                                                KODI_HTTP_HEADER_HDL hdl,
                                                                const char* param)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_VALUE>---*/

  std::string string = static_cast<CAddonHttpHeader*>(hdl)->GetValue(param);

  char* buffer = nullptr;
  if (!string.empty())
    buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_VALUE_END>---*/
}

char** CHdl_kodi_filesystem_h::kodi_vfs_http_header_get_values_v1(void* thisClassHdl,
                                                                  KODI_HTTP_HEADER_HDL hdl,
                                                                  const char* param,
                                                                  size_t* length)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_VALUES>---*/

  std::vector<std::string> values = static_cast<CAddonHttpHeader*>(hdl)->GetValues(param);
  *length = values.size();
  char** ret = static_cast<char**>(malloc(sizeof(char*) * values.size()));
  for (size_t i = 0; i < *length; ++i)
  {
    ret[i] = strdup(values[i].c_str());
  }
  return ret;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_VALUES_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_http_header_get_header_v1(void* thisClassHdl,
                                                                 KODI_HTTP_HEADER_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_HEADER>---*/
  // Code below must be set manually by hand to make work to Kodi

  std::string string = static_cast<CAddonHttpHeader*>(hdl)->GetHeader();

  char* buffer = nullptr;
  if (!string.empty())
    buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_HEADER_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_http_header_get_mime_type_v1(void* thisClassHdl,
                                                                    KODI_HTTP_HEADER_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_MIME_TYPE>---*/

  std::string string = static_cast<CAddonHttpHeader*>(hdl)->GetMimeType();

  char* buffer = nullptr;
  if (!string.empty())
    buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_MIME_TYPE_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_http_header_get_charset_v1(void* thisClassHdl,
                                                                  KODI_HTTP_HEADER_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_CHARSET>---*/

  std::string string = static_cast<CAddonHttpHeader*>(hdl)->GetCharset();

  char* buffer = nullptr;
  if (!string.empty())
    buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_CHARSET_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_http_header_get_proto_line_v1(void* thisClassHdl,
                                                                     KODI_HTTP_HEADER_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_PROTO_LINE>---*/

  std::string string = static_cast<CAddonHttpHeader*>(hdl)->GetProtoLine();

  char* buffer = nullptr;
  if (!string.empty())
    buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_HTTP_HEADER_GET_PROTO_LINE_END>---*/
}

KODI_FILE_HDL CHdl_kodi_filesystem_h::kodi_vfs_file_open_v1(void* thisClassHdl,
                                                            const char* filename,
                                                            unsigned int flags)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_OPEN>---*/

  CAddonFile* file = new CAddonFile;
  if (file->Open(filename, TranslateFileReadBitsToKodi(flags)))
    return static_cast<KODI_FILE_HDL>(file);

  delete file;
  return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_OPEN_END>---*/
}

KODI_FILE_HDL CHdl_kodi_filesystem_h::kodi_vfs_file_open_for_write_v1(void* thisClassHdl,
                                                                      const char* filename,
                                                                      bool overwrite)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_OPEN_FOR_WRITE>---*/

  CAddonFile* file = new CAddonFile;
  if (file->OpenForWrite(filename, overwrite))
    return static_cast<KODI_FILE_HDL>(file);

  delete file;
  return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_OPEN_FOR_WRITE_END>---*/
}

KODI_FILE_HDL CHdl_kodi_filesystem_h::kodi_vfs_file_curl_create_v1(void* thisClassHdl,
                                                                   const char* url)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CURL_CREATE>---*/

  CAddonFile* file = new CAddonFile;
  if (file->CURLCreate(url))
    return static_cast<KODI_FILE_HDL>(file);

  delete file;
  return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CURL_CREATE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_curl_add_option_v1(void* thisClassHdl,
                                                              KODI_FILE_HDL hdl,
                                                              enum CURLOptiontype type,
                                                              const char* name,
                                                              const char* value)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CURL_ADD_OPTION>---*/

  XFILE::CURLOPTIONTYPE internalType;
  switch (type)
  {
    case ADDON_CURL_OPTION_OPTION:
      internalType = XFILE::CURL_OPTION_OPTION;
      break;
    case ADDON_CURL_OPTION_PROTOCOL:
      internalType = XFILE::CURL_OPTION_PROTOCOL;
      break;
    case ADDON_CURL_OPTION_CREDENTIALS:
      internalType = XFILE::CURL_OPTION_CREDENTIALS;
      break;
    case ADDON_CURL_OPTION_HEADER:
      internalType = XFILE::CURL_OPTION_HEADER;
      break;
    default:
      throw std::logic_error("Interface_Filesystem::curl_add_option - invalid curl option type");
      return false;
  };

  return static_cast<CAddonFile*>(hdl)->CURLAddOption(internalType, name, value);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CURL_ADD_OPTION_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_curl_open_v1(void* thisClassHdl,
                                                        KODI_FILE_HDL hdl,
                                                        unsigned int flags)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CURL_OPEN>---*/

  return static_cast<CAddonFile*>(hdl)->CURLOpen(TranslateFileReadBitsToKodi(flags));

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CURL_OPEN_END>---*/
}

void CHdl_kodi_filesystem_h::kodi_vfs_file_close_v1(void* thisClassHdl, KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CLOSE>---*/

  static_cast<CAddonFile*>(hdl)->Close();
  delete static_cast<CAddonFile*>(hdl);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_CLOSE_END>---*/
}

ssize_t CHdl_kodi_filesystem_h::kodi_vfs_file_read_v1(void* thisClassHdl,
                                                      KODI_FILE_HDL hdl,
                                                      uint8_t* ptr,
                                                      size_t size)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_READ>---*/

  return static_cast<CAddonFile*>(hdl)->Read(ptr, size);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_READ_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_read_line_v1(void* thisClassHdl,
                                                        KODI_FILE_HDL hdl,
                                                        char* szLine,
                                                        size_t lineLength)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_READ_LINE>---*/

  return static_cast<CAddonFile*>(hdl)->ReadString(szLine, lineLength);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_READ_LINE_END>---*/
}

ssize_t CHdl_kodi_filesystem_h::kodi_vfs_file_write_v1(void* thisClassHdl,
                                                       KODI_FILE_HDL hdl,
                                                       const uint8_t* ptr,
                                                       size_t size)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_WRITE>---*/

  return static_cast<CAddonFile*>(hdl)->Write(ptr, size);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_WRITE_END>---*/
}

void CHdl_kodi_filesystem_h::kodi_vfs_file_flush_v1(void* thisClassHdl, KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_FLUSH>---*/

  static_cast<CAddonFile*>(hdl)->Flush();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_FLUSH_END>---*/
}

int64_t CHdl_kodi_filesystem_h::kodi_vfs_file_seek_v1(void* thisClassHdl,
                                                      KODI_FILE_HDL hdl,
                                                      int64_t position,
                                                      int whence)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_SEEK>---*/

  return static_cast<CAddonFile*>(hdl)->Seek(position, whence);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_SEEK_END>---*/
}

int CHdl_kodi_filesystem_h::kodi_vfs_file_truncate_v1(void* thisClassHdl,
                                                      KODI_FILE_HDL hdl,
                                                      int64_t size)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_TRUNCATE>---*/

  return static_cast<CAddonFile*>(hdl)->Truncate(size);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_TRUNCATE_END>---*/
}

int64_t CHdl_kodi_filesystem_h::kodi_vfs_file_get_position_v1(void* thisClassHdl, KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_POSITION>---*/

  return static_cast<CAddonFile*>(hdl)->GetPosition();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_POSITION_END>---*/
}

int64_t CHdl_kodi_filesystem_h::kodi_vfs_file_get_length_v1(void* thisClassHdl, KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_LENGTH>---*/

  return static_cast<CAddonFile*>(hdl)->GetLength();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_LENGTH_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_at_end_v1(void* thisClassHdl, KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_AT_END>---*/

  int64_t length = kodi_vfs_file_get_length_v1(thisClassHdl, hdl);
  int64_t position = kodi_vfs_file_get_position_v1(thisClassHdl, hdl);
  return position >= length;


  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_AT_END_END>---*/
}

double CHdl_kodi_filesystem_h::kodi_vfs_file_get_download_speed_v1(void* thisClassHdl,
                                                                   KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return 0.0;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_DOWNLOAD_SPEED>---*/

  return static_cast<CAddonFile*>(hdl)->GetDownloadSpeed();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_DOWNLOAD_SPEED_END>---*/
}

int CHdl_kodi_filesystem_h::kodi_vfs_file_get_chunk_size_v1(void* thisClassHdl, KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_CHUNK_SIZE>---*/

  return static_cast<CAddonFile*>(hdl)->GetChunkSize();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_CHUNK_SIZE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_io_ctl_get_seek_possible_v1(void* thisClassHdl,
                                                                       KODI_FILE_HDL hdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_GET_SEEK_POSSIBLE>---*/

  return static_cast<CAddonFile*>(hdl)->IoControl(EIoControl::IOCTRL_SEEK_POSSIBLE, nullptr) != 0
             ? true
             : false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_GET_SEEK_POSSIBLE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_io_ctl_get_cache_status_v1(
    void* thisClassHdl, KODI_FILE_HDL hdl, struct VFS_CACHE_STATUS* status)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_GET_CACHE_STATUS>---*/

  SCacheStatus data = {0};
  int ret = static_cast<CAddonFile*>(hdl)->IoControl(EIoControl::IOCTRL_CACHE_STATUS, &data);
  if (ret >= 0)
  {
    status->forward = data.forward;
    status->maxrate = data.maxrate;
    status->currate = data.currate;
    status->lowspeed = data.lowspeed;
    return true;
  }
  return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_GET_CACHE_STATUS_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_io_ctl_set_cache_rate_v1(void* thisClassHdl,
                                                                    KODI_FILE_HDL hdl,
                                                                    unsigned int rate)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_SET_CACHE_RATE>---*/

  return static_cast<CAddonFile*>(hdl)->IoControl(EIoControl::IOCTRL_CACHE_SETRATE, &rate) >= 0
             ? true
             : false;


  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_SET_CACHE_RATE_END>---*/
}

bool CHdl_kodi_filesystem_h::kodi_vfs_file_io_ctl_set_retry_v1(void* thisClassHdl,
                                                               KODI_FILE_HDL hdl,
                                                               bool retry)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_SET_RETRY>---*/

  return static_cast<CAddonFile*>(hdl)->IoControl(EIoControl::IOCTRL_SET_RETRY, &retry) >= 0
             ? true
             : false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_IO_CTL_SET_RETRY_END>---*/
}

char* CHdl_kodi_filesystem_h::kodi_vfs_file_get_property_value_v1(void* thisClassHdl,
                                                                  KODI_FILE_HDL hdl,
                                                                  enum FilePropertyTypes type,
                                                                  const char* name)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_PROPERTY_VALUE>---*/

  XFILE::FileProperty internalType = TranslateFilePropertyToKodi(type);
  return strdup(static_cast<CAddonFile*>(hdl)->GetProperty(internalType, name).c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_PROPERTY_VALUE_END>---*/
}

char** CHdl_kodi_filesystem_h::kodi_vfs_file_get_property_values_v1(void* thisClassHdl,
                                                                    KODI_FILE_HDL hdl,
                                                                    enum FilePropertyTypes type,
                                                                    const char* name,
                                                                    size_t* length)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_filesystem_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_PROPERTY_VALUES>---*/

  XFILE::FileProperty internalType = TranslateFilePropertyToKodi(type);
  std::vector<std::string> values =
      static_cast<CAddonFile*>(hdl)->GetPropertyValues(internalType, name);
  *length = values.size();
  char** ret = static_cast<char**>(malloc(sizeof(char*) * values.size()));
  for (size_t i = 0; i < *length; ++i)
  {
    ret[i] = strdup(values[i].c_str());
  }
  return ret;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FILE_GET_PROPERTY_VALUES_END>---*/
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

} /* namespace INTERFACE */
} /* namespace ADDONS */
} /* namespace KODI */
