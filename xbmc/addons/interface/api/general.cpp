/*
 *  Copyright (C) 2005-2021 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "general.h"

// Shared API
#include "addons/kodi-dev-kit/src/shared/api/general.h"

// Kodi
#include "addons/interface/RunningProcess.h"
#include "utils/log.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
#include "Application.h"
#include "CompileInfo.h"
#include "LangInfo.h"
#include "ServiceBroker.h"
#include "addons/AddonManager.h"
#include "addons/gui/GUIDialogAddonSettings.h"
#include "cores/AudioEngine/Interfaces/AE.h"
#include "dialogs/GUIDialogKaiToast.h"
#include "filesystem/Directory.h"
#include "filesystem/File.h"
#include "filesystem/SpecialProtocol.h"
#include "guilib/GUIAudioManager.h"
#include "guilib/GUIComponent.h"
#include "guilib/LocalizeStrings.h"
#include "input/KeyboardLayout.h"
#include "input/KeyboardLayoutManager.h"
#include "settings/Settings.h"
#include "settings/SettingsComponent.h"
#include "utils/CharsetConverter.h"
#include "utils/Digest.h"
#include "utils/LangCodeExpander.h"
#include "utils/MemUtils.h"
#include "utils/StringUtils.h"
#include "utils/URIUtils.h"

using namespace ADDON;
using namespace KODI::UTILITY;

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

namespace KODI
{
namespace ADDONS
{
namespace INTERFACE
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_general_h::InitDirect(directFuncToKodi_general_h* ifcToKodi,
                                     directFuncToAddon_general_h* ifcToAddon)
{
  ifcToKodi->thisClassHdl = this;
  m_ifcToAddon = ifcToAddon;
  ifcToKodi->kodi_get_localized_string_v1 = kodi_get_localized_string_v1;
  ifcToKodi->kodi_get_free_mem_v1 = kodi_get_free_mem_v1;
  ifcToKodi->kodi_unknown_to_utf8_v1 = kodi_unknown_to_utf8_v1;
  ifcToKodi->kodi_get_language_v1 = kodi_get_language_v1;
  ifcToKodi->kodi_queue_notification_v1 = kodi_queue_notification_v1;
  ifcToKodi->kodi_get_digest_v1 = kodi_get_digest_v1;
  ifcToKodi->kodi_get_region_v1 = kodi_get_region_v1;
  ifcToKodi->kodi_get_global_idle_time_v1 = kodi_get_global_idle_time_v1;
  ifcToKodi->kodi_is_addon_avilable_v1 = kodi_is_addon_avilable_v1;
  ifcToKodi->kodi_version_v1 = kodi_version_v1;
  ifcToKodi->kodi_get_current_skin_id_v1 = kodi_get_current_skin_id_v1;
  ifcToKodi->kodi_get_keyboard_layout_v1 = kodi_get_keyboard_layout_v1;
  ifcToKodi->kodi_change_keyboard_layout_v1 = kodi_change_keyboard_layout_v1;
  ifcToKodi->kodi_play_sfx_v1 = kodi_play_sfx_v1;
  ifcToKodi->kodi_stop_sfx_v1 = kodi_stop_sfx_v1;
}

bool CHdl_kodi_general_h::HandleMessage(int funcGroup,
                                        int func,
                                        const msgpack::unpacked& in,
                                        msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_general_h)
    return false;

  switch (func)
  {
    case funcParent_kodi_get_localized_string_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_get_localized_string(long label_id) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<long> msgParent__IN_kodi_get_localized_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_get_localized_string_v1; /* Autogenerated */
      msgParent__IN_kodi_get_localized_string_v1 t = in.get().as<decltype(t)>();
      long label_id = std::get<0>(t);
      char* auto_gen_ret = kodi_get_localized_string_v1(this, label_id);
      msgpack::pack(out,
                    msgParent_OUT_kodi_get_localized_string_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_get_free_mem_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_get_free_mem(long* free, long* total, bool as_bytes) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<long, long, bool> msgParent__IN_kodi_get_free_mem_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<long, long> msgParent_OUT_kodi_get_free_mem_v1; /* Autogenerated */
      msgParent__IN_kodi_get_free_mem_v1 t = in.get().as<decltype(t)>();
      long free = std::get<0>(t);
      long total = std::get<1>(t);
      bool as_bytes = std::get<2>(t);
      kodi_get_free_mem_v1(this, &free, &total, as_bytes);
      msgpack::pack(out, msgParent_OUT_kodi_get_free_mem_v1(free, total));
      return true;
    }
    case funcParent_kodi_unknown_to_utf8_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_unknown_to_utf8(const char* source, bool* ret, bool failOnBadChar) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool, bool> msgParent__IN_kodi_unknown_to_utf8_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string, bool> msgParent_OUT_kodi_unknown_to_utf8_v1; /* Autogenerated */
      msgParent__IN_kodi_unknown_to_utf8_v1 t = in.get().as<decltype(t)>();
      const std::string& source = std::get<0>(t);
      bool ret = std::get<1>(t);
      bool failOnBadChar = std::get<2>(t);
      char* auto_gen_ret = kodi_unknown_to_utf8_v1(this, source.c_str(), &ret, failOnBadChar);
      msgpack::pack(out,
                    msgParent_OUT_kodi_unknown_to_utf8_v1(auto_gen_ret ? auto_gen_ret : "", ret));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_get_language_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_get_language(enum LangFormats format, bool region) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<LangFormats, bool> msgParent__IN_kodi_get_language_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_get_language_v1; /* Autogenerated */
      msgParent__IN_kodi_get_language_v1 t = in.get().as<decltype(t)>();
      enum LangFormats format = std::get<0>(t);
      bool region = std::get<1>(t);
      char* auto_gen_ret = kodi_get_language_v1(this, format, region);
      msgpack::pack(out, msgParent_OUT_kodi_get_language_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_queue_notification_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_queue_notification(enum QueueMsg type, const char* header, const char* message, const char* imageFile, unsigned int displayTime, bool withSound, unsigned int messageTime) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<QueueMsg, std::string, std::string, std::string, unsigned int, bool, unsigned int> msgParent__IN_kodi_queue_notification_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_queue_notification_v1; /* Autogenerated */
      msgParent__IN_kodi_queue_notification_v1 t = in.get().as<decltype(t)>();
      enum QueueMsg type = std::get<0>(t);
      const std::string& header = std::get<1>(t);
      const std::string& message = std::get<2>(t);
      const std::string& imageFile = std::get<3>(t);
      unsigned int displayTime = std::get<4>(t);
      bool withSound = std::get<5>(t);
      unsigned int messageTime = std::get<6>(t);
      kodi_queue_notification_v1(this, type, header.c_str(), message.c_str(), imageFile.c_str(),
                                 displayTime, withSound, messageTime);
      return true;
    }
    case funcParent_kodi_get_digest_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_get_digest(enum DigestType type, const char* text) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DigestType, std::string> msgParent__IN_kodi_get_digest_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_get_digest_v1; /* Autogenerated */
      msgParent__IN_kodi_get_digest_v1 t = in.get().as<decltype(t)>();
      enum DigestType type = std::get<0>(t);
      const std::string& text = std::get<1>(t);
      char* auto_gen_ret = kodi_get_digest_v1(this, type, text.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_get_digest_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_get_region_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_get_region(const char* id) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_get_region_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_get_region_v1; /* Autogenerated */
      msgParent__IN_kodi_get_region_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      char* auto_gen_ret = kodi_get_region_v1(this, id.c_str());
      msgpack::pack(out, msgParent_OUT_kodi_get_region_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_get_global_idle_time_v1:
    {
      // Original API call: ATTR_DLL_EXPORT int kodi_get_global_idle_time() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_get_global_idle_time_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_get_global_idle_time_v1; /* Autogenerated */
      int auto_gen_ret = kodi_get_global_idle_time_v1(this);
      msgpack::pack(out, msgParent_OUT_kodi_get_global_idle_time_v1(auto_gen_ret));
      return true;
    }
    case funcParent_kodi_is_addon_avilable_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_is_addon_avilable(const char* id, char** version, bool* enabled) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_is_addon_avilable_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string, bool> msgParent_OUT_kodi_is_addon_avilable_v1; /* Autogenerated */
      msgParent__IN_kodi_is_addon_avilable_v1 t = in.get().as<decltype(t)>();
      const std::string& id = std::get<0>(t);
      char* version = nullptr;
      bool enabled = std::get<1>(t);
      bool auto_gen_ret = kodi_is_addon_avilable_v1(this, id.c_str(), &version, &enabled);
      msgpack::pack(out, msgParent_OUT_kodi_is_addon_avilable_v1(auto_gen_ret,
                                                                 version ? version : "", enabled));
      if (version)
        free(version);
      return true;
    }
    case funcParent_kodi_version_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_version( char** compile_name, int* major, int* minor, char** revision, char** tag, char** tagversion) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<int, int> msgParent__IN_kodi_version_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string, int, int, std::string, std::string, std::string> msgParent_OUT_kodi_version_v1; /* Autogenerated */
      msgParent__IN_kodi_version_v1 t = in.get().as<decltype(t)>();
      char* compile_name = nullptr;
      int major = std::get<0>(t);
      int minor = std::get<1>(t);
      char* revision = nullptr;
      char* tag = nullptr;
      char* tagversion = nullptr;
      kodi_version_v1(this, &compile_name, &major, &minor, &revision, &tag, &tagversion);
      msgpack::pack(out,
                    msgParent_OUT_kodi_version_v1(compile_name ? compile_name : "", major, minor,
                                                  revision ? revision : "", tag ? tag : "",
                                                  tagversion ? tagversion : ""));
      if (compile_name)
        free(compile_name);
      if (revision)
        free(revision);
      if (tag)
        free(tag);
      if (tagversion)
        free(tagversion);
      return true;
    }
    case funcParent_kodi_get_current_skin_id_v1:
    {
      // Original API call: ATTR_DLL_EXPORT char* kodi_get_current_skin_id() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_get_current_skin_id_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_get_current_skin_id_v1; /* Autogenerated */
      char* auto_gen_ret = kodi_get_current_skin_id_v1(this);
      msgpack::pack(out,
                    msgParent_OUT_kodi_get_current_skin_id_v1(auto_gen_ret ? auto_gen_ret : ""));
      if (auto_gen_ret)
        free(auto_gen_ret);
      return true;
    }
    case funcParent_kodi_get_keyboard_layout_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_get_keyboard_layout(int modifier_key, char** layout_name, struct AddonKeyboardKeyTable* layout) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<int> msgParent__IN_kodi_get_keyboard_layout_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string, IFC_AddonKeyboardKeyTable> msgParent_OUT_kodi_get_keyboard_layout_v1; /* Autogenerated */
      msgParent__IN_kodi_get_keyboard_layout_v1 t = in.get().as<decltype(t)>();
      int modifier_key = std::get<0>(t);
      char* layout_name = nullptr;
      struct AddonKeyboardKeyTable layout;
      bool auto_gen_ret = kodi_get_keyboard_layout_v1(this, modifier_key, &layout_name, &layout);
      msgpack::pack(out, msgParent_OUT_kodi_get_keyboard_layout_v1(
                             auto_gen_ret, layout_name ? layout_name : "", &layout));
      if (layout_name)
        free(layout_name);
      return true;
    }
    case funcParent_kodi_change_keyboard_layout_v1:
    {
      // Original API call: ATTR_DLL_EXPORT bool kodi_change_keyboard_layout(char** layout_name) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_change_keyboard_layout_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_change_keyboard_layout_v1; /* Autogenerated */
      msgParent__IN_kodi_change_keyboard_layout_v1 t = in.get().as<decltype(t)>();
      char* layout_name = nullptr;
      bool auto_gen_ret = kodi_change_keyboard_layout_v1(this, &layout_name);
      msgpack::pack(out, msgParent_OUT_kodi_change_keyboard_layout_v1(
                             auto_gen_ret, layout_name ? layout_name : ""));
      if (layout_name)
        free(layout_name);
      return true;
    }
    case funcParent_kodi_play_sfx_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_play_sfx(const char* filename, bool use_cached) __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_play_sfx_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_play_sfx_v1; /* Autogenerated */
      msgParent__IN_kodi_play_sfx_v1 t = in.get().as<decltype(t)>();
      const std::string& filename = std::get<0>(t);
      bool use_cached = std::get<1>(t);
      kodi_play_sfx_v1(this, filename.c_str(), use_cached);
      return true;
    }
    case funcParent_kodi_stop_sfx_v1:
    {
      // Original API call: ATTR_DLL_EXPORT void kodi_stop_sfx() __INTRODUCED_IN_KODI(1);
      // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_stop_sfx_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_stop_sfx_v1; /* Autogenerated */
      kodi_stop_sfx_v1(this);
      return true;
    }
    default:
      CLog::Log(LOGERROR,
                "CHdl_kodi_general_h::{}: addon called with unknown function id '{}' on group "
                "'general_h'",
                __func__, func);
  }

  return false;
}

// Function calls from Kodi to addon
/* NOTE: unused (no functions here) */

// Callbacks from addon to Kodi

char* CHdl_kodi_general_h::kodi_get_localized_string_v1(void* thisClassHdl, long label_id)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_LOCALIZED_STRING>---*/

  if (g_application.m_bStop)
    return nullptr;

  std::string label =
      g_localizeStrings.GetAddonString(thisClass->m_process->GetAddonID(), label_id);
  if (label.empty())
    label = g_localizeStrings.Get(label_id);
  char* buffer = strdup(label.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_LOCALIZED_STRING_END>---*/
}

void CHdl_kodi_general_h::kodi_get_free_mem_v1(void* thisClassHdl,
                                               long* free,
                                               long* total,
                                               bool as_bytes)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_FREE_MEM>---*/

  KODI::MEMORY::MemoryStatus stat;
  KODI::MEMORY::GetMemoryStatus(&stat);
  *free = static_cast<long>(stat.availPhys);
  *total = static_cast<long>(stat.totalPhys);
  if (!as_bytes)
  {
    *free = *free / (1024 * 1024);
    *total = *total / (1024 * 1024);
  }

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_FREE_MEM_END>---*/
}

char* CHdl_kodi_general_h::kodi_unknown_to_utf8_v1(void* thisClassHdl,
                                                   const char* source,
                                                   bool* ret,
                                                   bool failOnBadChar)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_UNKNOWN_TO_UTF8>---*/

  std::string string;
  *ret = g_charsetConverter.unknownToUTF8(source, string, failOnBadChar);
  char* buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_UNKNOWN_TO_UTF8_END>---*/
}

char* CHdl_kodi_general_h::kodi_get_language_v1(void* thisClassHdl,
                                                enum LangFormats format,
                                                bool region)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_LANGUAGE>---*/

  std::string string = g_langInfo.GetEnglishLanguageName();
  switch (format)
  {
    case LANG_FMT_ISO_639_1:
    {
      std::string langCode;
      g_LangCodeExpander.ConvertToISO6391(string, langCode);
      string = langCode;
      if (region)
      {
        std::string region2Code;
        g_LangCodeExpander.ConvertToISO6391(g_langInfo.GetRegionLocale(), region2Code);
        if (!region2Code.empty())
          string += "-" + region2Code;
      }
      break;
    }
    case LANG_FMT_ISO_639_2:
    {
      std::string langCode;
      g_LangCodeExpander.ConvertToISO6392B(string, langCode);
      string = langCode;
      if (region)
      {
        std::string region3Code;
        g_LangCodeExpander.ConvertToISO6392B(g_langInfo.GetRegionLocale(), region3Code);
        if (!region3Code.empty())
          string += "-" + region3Code;
      }
      break;
    }
    case LANG_FMT_ENGLISH_NAME:
    default:
    {
      if (region)
        string += "-" + g_langInfo.GetCurrentRegion();
      break;
    }
  }

  char* buffer = strdup(string.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_LANGUAGE_END>---*/
}

void CHdl_kodi_general_h::kodi_queue_notification_v1(void* thisClassHdl,
                                                     enum QueueMsg type,
                                                     const char* header,
                                                     const char* message,
                                                     const char* imageFile,
                                                     unsigned int displayTime,
                                                     bool withSound,
                                                     unsigned int messageTime)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_QUEUE_NOTIFICATION>---*/

  std::shared_ptr<IAddon> addon = thisClass->m_process->GetAddon();

  std::string usedHeader;
  if (header && strlen(header) > 0)
    usedHeader = header;
  else
    usedHeader = addon->Name();

  QueueMsg qtype = static_cast<QueueMsg>(type);

  if (qtype != QUEUE_OWN_STYLE)
  {
    CGUIDialogKaiToast::eMessageType usedType;
    switch (qtype)
    {
      case QueueMsg::QUEUE_WARNING:
        usedType = CGUIDialogKaiToast::Warning;
        withSound = true;
        CLog::Log(LOGDEBUG, "Interface_General::{} - {} - Warning Message: '{}'", __func__,
                  addon->Name(), message);
        break;
      case QueueMsg::QUEUE_ERROR:
        usedType = CGUIDialogKaiToast::Error;
        withSound = true;
        CLog::Log(LOGDEBUG, "Interface_General::{} - {} - Error Message : '{}'", __func__,
                  addon->Name(), message);
        break;
      case QueueMsg::QUEUE_INFO:
      default:
        usedType = CGUIDialogKaiToast::Info;
        withSound = false;
        CLog::Log(LOGDEBUG, "Interface_General::{} - {} - Info Message : '{}'", __func__,
                  addon->Name(), message);
        break;
    }

    if (imageFile && strlen(imageFile) > 0)
    {
      CLog::Log(LOGERROR,
                "Interface_General::{} - To use given image file '{}' must be type value set to "
                "'QUEUE_OWN_STYLE'",
                __func__, imageFile);
    }

    CGUIDialogKaiToast::QueueNotification(usedType, usedHeader, message, 3000, withSound);
  }
  else
  {
    CGUIDialogKaiToast::QueueNotification(imageFile, usedHeader, message, displayTime, withSound,
                                          messageTime);
  }

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_QUEUE_NOTIFICATION_END>---*/
}

char* CHdl_kodi_general_h::kodi_get_digest_v1(void* thisClassHdl,
                                              enum DigestType type,
                                              const char* text)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_DIGEST>---*/

  switch (type)
  {
    case DIGEST_MD5:
      return strdup(CDigest::Calculate(CDigest::Type::MD5, text).c_str());
    case DIGEST_SHA1:
      return strdup(CDigest::Calculate(CDigest::Type::SHA1, text).c_str());
    case DIGEST_SHA256:
      return strdup(CDigest::Calculate(CDigest::Type::SHA256, text).c_str());
    case DIGEST_SHA512:
      return strdup(CDigest::Calculate(CDigest::Type::SHA512, text).c_str());
    default:
      return nullptr;
  }

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_DIGEST_END>---*/
}

char* CHdl_kodi_general_h::kodi_get_region_v1(void* thisClassHdl, const char* id)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_REGION>---*/

  std::shared_ptr<IAddon> addon = thisClass->m_process->GetAddon();

  std::string result;
  if (StringUtils::CompareNoCase(id, "datelong") == 0)
  {
    result = g_langInfo.GetDateFormat(true);
    StringUtils::Replace(result, "DDDD", "%A");
    StringUtils::Replace(result, "MMMM", "%B");
    StringUtils::Replace(result, "D", "%d");
    StringUtils::Replace(result, "YYYY", "%Y");
  }
  else if (StringUtils::CompareNoCase(id, "dateshort") == 0)
  {
    result = g_langInfo.GetDateFormat(false);
    StringUtils::Replace(result, "MM", "%m");
    StringUtils::Replace(result, "DD", "%d");
#ifdef TARGET_WINDOWS
    StringUtils::Replace(result, "M", "%#m");
    StringUtils::Replace(result, "D", "%#d");
#else
    StringUtils::Replace(result, "M", "%-m");
    StringUtils::Replace(result, "D", "%-d");
#endif
    StringUtils::Replace(result, "YYYY", "%Y");
  }
  else if (StringUtils::CompareNoCase(id, "tempunit") == 0)
    result = g_langInfo.GetTemperatureUnitString();
  else if (StringUtils::CompareNoCase(id, "speedunit") == 0)
    result = g_langInfo.GetSpeedUnitString();
  else if (StringUtils::CompareNoCase(id, "time") == 0)
  {
    result = g_langInfo.GetTimeFormat();
    StringUtils::Replace(result, "H", "%H");
    StringUtils::Replace(result, "h", "%I");
    StringUtils::Replace(result, "mm", "%M");
    StringUtils::Replace(result, "ss", "%S");
    StringUtils::Replace(result, "xx", "%p");
  }
  else if (StringUtils::CompareNoCase(id, "meridiem") == 0)
    result = StringUtils::Format("%s/%s", g_langInfo.GetMeridiemSymbol(MeridiemSymbolAM).c_str(),
                                 g_langInfo.GetMeridiemSymbol(MeridiemSymbolPM).c_str());
  else
  {
    CLog::Log(LOGERROR, "Interface_General::{} -  add-on '{}' requests invalid id '{}'", __func__,
              addon->Name(), id);
    return nullptr;
  }

  char* buffer = strdup(result.c_str());
  return buffer;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_REGION_END>---*/
}

int CHdl_kodi_general_h::kodi_get_global_idle_time_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return -1;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_GLOBAL_IDLE_TIME>---*/

  return g_application.GlobalIdleTime();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_GLOBAL_IDLE_TIME_END>---*/
}

bool CHdl_kodi_general_h::kodi_is_addon_avilable_v1(void* thisClassHdl,
                                                    const char* id,
                                                    char** version,
                                                    bool* enabled)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_IS_ADDON_AVILABLE>---*/

  AddonPtr addonInfo;
  if (!CServiceBroker::GetAddonMgr().GetAddon(id, addonInfo, ADDON_UNKNOWN, OnlyEnabled::NO))
    return false;

  *version = strdup(addonInfo->Version().asString().c_str());
  *enabled = !CServiceBroker::GetAddonMgr().IsAddonDisabled(id);

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_IS_ADDON_AVILABLE_END>---*/
}

void CHdl_kodi_general_h::kodi_version_v1(void* thisClassHdl,
                                          char** compile_name,
                                          int* major,
                                          int* minor,
                                          char** revision,
                                          char** tag,
                                          char** tagversion)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VERSION>---*/

  *compile_name = strdup(CCompileInfo::GetAppName());
  *major = CCompileInfo::GetMajor();
  *minor = CCompileInfo::GetMinor();
  *revision = strdup(CCompileInfo::GetSCMID());
  std::string tagStr = CCompileInfo::GetSuffix();
  if (StringUtils::StartsWithNoCase(tagStr, "alpha"))
  {
    *tag = strdup("alpha");
    *tagversion = strdup(StringUtils::Mid(tagStr, 5).c_str());
  }
  else if (StringUtils::StartsWithNoCase(tagStr, "beta"))
  {
    *tag = strdup("beta");
    *tagversion = strdup(StringUtils::Mid(tagStr, 4).c_str());
  }
  else if (StringUtils::StartsWithNoCase(tagStr, "rc"))
  {
    *tag = strdup("releasecandidate");
    *tagversion = strdup(StringUtils::Mid(tagStr, 2).c_str());
  }
  else if (tagStr.empty())
    *tag = strdup("stable");
  else
    *tag = strdup("prealpha");

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VERSION_END>---*/
}

char* CHdl_kodi_general_h::kodi_get_current_skin_id_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_CURRENT_SKIN_ID>---*/

  return strdup(CServiceBroker::GetSettingsComponent()
                    ->GetSettings()
                    ->GetString(CSettings::SETTING_LOOKANDFEEL_SKIN)
                    .c_str());

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_CURRENT_SKIN_ID_END>---*/
}

bool CHdl_kodi_general_h::kodi_get_keyboard_layout_v1(void* thisClassHdl,
                                                      int modifier_key,
                                                      char** layout_name,
                                                      struct AddonKeyboardKeyTable* layout)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_KEYBOARD_LAYOUT>---*/

  const std::string activeLayout = CServiceBroker::GetSettingsComponent()->GetSettings()->GetString(
      CSettings::SETTING_LOCALE_ACTIVEKEYBOARDLAYOUT);

  CKeyboardLayout cpp_layout;
  if (!CKeyboardLayoutManager::GetInstance().GetLayout(activeLayout, cpp_layout))
    return false;

  *layout_name = strdup(cpp_layout.GetName().c_str());

  unsigned int modifiers = CKeyboardLayout::ModifierKeyNone;
  if (modifier_key & STD_KB_MODIFIER_KEY_SHIFT)
    modifiers |= CKeyboardLayout::ModifierKeyShift;
  if (modifier_key & STD_KB_MODIFIER_KEY_SYMBOL)
    modifiers |= CKeyboardLayout::ModifierKeySymbol;

  for (unsigned int row = 0; row < STD_KB_BUTTONS_MAX_ROWS; row++)
  {
    for (unsigned int column = 0; column < STD_KB_BUTTONS_PER_ROW; column++)
    {
      std::string label = cpp_layout.GetCharAt(row, column, modifiers);
      layout->keys[row][column] = strdup(label.c_str());
    }
  }

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_GET_KEYBOARD_LAYOUT_END>---*/
}

bool CHdl_kodi_general_h::kodi_change_keyboard_layout_v1(void* thisClassHdl, char** layout_name)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return false;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_CHANGE_KEYBOARD_LAYOUT>---*/

  std::vector<CKeyboardLayout> layouts;
  unsigned int currentLayout = 0;

  const KeyboardLayouts& keyboardLayouts = CKeyboardLayoutManager::GetInstance().GetLayouts();
  const std::shared_ptr<CSettings> settings = CServiceBroker::GetSettingsComponent()->GetSettings();
  const std::vector<CVariant> layoutNames =
      settings->GetList(CSettings::SETTING_LOCALE_KEYBOARDLAYOUTS);
  const std::string activeLayout =
      settings->GetString(CSettings::SETTING_LOCALE_ACTIVEKEYBOARDLAYOUT);

  for (const auto& layoutName : layoutNames)
  {
    const auto keyboardLayout = keyboardLayouts.find(layoutName.asString());
    if (keyboardLayout != keyboardLayouts.end())
    {
      layouts.emplace_back(keyboardLayout->second);
      if (layoutName.asString() == activeLayout)
        currentLayout = layouts.size() - 1;
    }
  }

  currentLayout++;
  if (currentLayout >= layouts.size())
    currentLayout = 0;
  CKeyboardLayout layout = layouts.empty() ? CKeyboardLayout() : layouts[currentLayout];
  CServiceBroker::GetSettingsComponent()->GetSettings()->SetString(
      CSettings::SETTING_LOCALE_ACTIVEKEYBOARDLAYOUT, layout.GetName());

  *layout_name = strdup(layout.GetName().c_str());

  return true;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_CHANGE_KEYBOARD_LAYOUT_END>---*/
}

void CHdl_kodi_general_h::kodi_play_sfx_v1(void* thisClassHdl,
                                           const char* filename,
                                           bool use_cached)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_PLAY_SFX>---*/

  CGUIComponent* gui = CServiceBroker::GetGUI();
  if (XFILE::CFile::Exists(filename) && gui)
  {
    gui->GetAudioManager().PlayPythonSound(filename, use_cached);
  }

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_PLAY_SFX_END>---*/
}

void CHdl_kodi_general_h::kodi_stop_sfx_v1(void* thisClassHdl)
{
  auto thisClass = reinterpret_cast<CHdl_kodi_general_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_STOP_SFX>---*/

  CGUIComponent* gui = CServiceBroker::GetGUI();
  if (gui)
    gui->GetAudioManager().Stop();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_STOP_SFX_END>---*/
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

} /* namespace INTERFACE */
} /* namespace ADDONS */
} /* namespace KODI */
