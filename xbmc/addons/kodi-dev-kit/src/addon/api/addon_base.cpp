/*
 *  Copyright (C) 2005-2021 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "addon_base.h"

#include "include/kodi/tools/StringUtils.h"

// Shared API
#include "src/shared/Instances.h"

// Lib code
#include "core/addon_control.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

using namespace KODI::ADDONS::INTERFACE;
using namespace KODI_ADDON::INTERNAL;

namespace KODI_ADDON
{
namespace INTERNAL
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_addon_base_h::InitDirect(directFuncToAddon_addon_base_h* ifcToAddon)
{
  ifcToAddon->thisClassHdl = this;
  ifcToAddon->kodi_addon_create_v1 = kodi_addon_create_v1;
  ifcToAddon->kodi_addon_destroy_v1 = kodi_addon_destroy_v1;
  ifcToAddon->kodi_addon_create_instance_v1 = kodi_addon_create_instance_v1;
  ifcToAddon->kodi_addon_destroy_instance_v1 = kodi_addon_destroy_instance_v1;
  ifcToAddon->kodi_addon_setting_change_string_v1 = kodi_addon_setting_change_string_v1;
  ifcToAddon->kodi_addon_setting_change_boolean_v1 = kodi_addon_setting_change_boolean_v1;
  ifcToAddon->kodi_addon_setting_change_integer_v1 = kodi_addon_setting_change_integer_v1;
  ifcToAddon->kodi_addon_setting_change_float_v1 = kodi_addon_setting_change_float_v1;
}

#ifndef KODI_INHIBIT_SHARED
bool CHdl_kodi_addon_base_h::HandleMessage(int funcGroup,
                                           int func,
                                           const msgpack::unpacked& in,
                                           msgpack::sbuffer& out)
{
  if (funcGroup != funcGroup_addon_base_h)
    return false;

  switch (func)
  {
    case funcChild_kodi_addon_create_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_CREATE_V1)(KODI_HANDLE first_instance, KODI_ADDON_HDL* hdl);
      // Tuple in:          typedef std::tuple<DummyValue> msgChild__IN_kodi_addon_create_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */
      // Tuple out:         typedef std::tuple<ADDON_STATUS, PtrValue> msgChild_OUT_kodi_addon_create_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_V1>---*/

      KODI_ADDON_HDL hdl = nullptr;
      enum ADDON_STATUS auto_gen_ret = kodi_addon_create_v1(this, &hdl);

      msgpack::pack(out, msgChild_OUT_kodi_addon_create_v1(auto_gen_ret, PtrValue(hdl)));

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_V1_END>---*/
      return true;
    }
    case funcChild_kodi_addon_destroy_v1:
    {
      // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_DESTROY_V1)(KODI_ADDON_HDL hdl);
      // Tuple in:          typedef std::tuple<PtrValue> msgChild__IN_kodi_addon_destroy_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_destroy_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_destroy_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      kodi_addon_destroy_v1(this, auto_gen_hdl);

      return true;
    }
    case funcChild_kodi_addon_create_instance_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_CREATE_INSTANCE_V1)(const KODI_ADDON_HDL hdl, enum ADDON_INSTANCE instanceType, const char* instanceID, struct KODI_INSTANCE_HDL* addonInstance, KODI_IFC_HDL parent);
      // Tuple in:          typedef std::tuple<PtrValue, ADDON_INSTANCE, std::string, PtrValue, PtrValue> msgChild__IN_kodi_addon_create_instance_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */
      // Tuple out:         typedef std::tuple<ADDON_STATUS, PtrValue> msgChild_OUT_kodi_addon_create_instance_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1>---*/

      msgChild__IN_kodi_addon_create_instance_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      enum ADDON_INSTANCE instanceType = std::get<1>(t);
      const std::string& instanceID = std::get<2>(t);
      KODI_OWN_HDL instance = reinterpret_cast<KODI_OWN_HDL>(std::get<3>(t));
      KODI_HANDLE addonInstance = nullptr;
      KODI_IFC_HDL parent = reinterpret_cast<KODI_IFC_HDL>(std::get<4>(t));
      enum ADDON_STATUS auto_gen_ret = kodi_addon_create_instance_v1(
          this, hdl, instanceType, instanceID, instance, &addonInstance, parent);

      msgpack::pack(
          out, msgChild_OUT_kodi_addon_create_instance_v1(auto_gen_ret, PtrValue(addonInstance)));

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1_END>---*/
      return true;
    }
    case funcChild_kodi_addon_destroy_instance_v1:
    {
      // Original API call: typedef void(ATTR_APIENTRYP PFN_KODI_ADDON_DESTROY_INSTANCE_V1)(const KODI_ADDON_HDL hdl, enum ADDON_INSTANCE instanceType, struct KODI_INSTANCE_HDL* instance);
      // Tuple in:          typedef std::tuple<PtrValue, ADDON_INSTANCE, PtrValue> msgChild__IN_kodi_addon_destroy_instance_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */
      // Tuple out:         typedef std::tuple<DummyValue> msgChild_OUT_kodi_addon_destroy_instance_v1; /* OVERRIDE;USE_HAND_MAKE used, set this by hand */

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1>---*/

      msgChild__IN_kodi_addon_destroy_instance_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      enum ADDON_INSTANCE instanceType = std::get<1>(t);
      KODI_HANDLE instance = reinterpret_cast<KODI_HANDLE>(std::get<2>(t));
      kodi_addon_destroy_instance_v1(this, hdl, instanceType, instance);

      /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1_END>---*/
      return true;
    }
    case funcChild_kodi_addon_setting_change_string_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_STRING_V1)(const KODI_ADDON_HDL hdl, const char* name, const char* value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, std::string> msgChild__IN_kodi_addon_setting_change_string_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_string_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_string_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      const std::string& value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_string_v1(this, auto_gen_hdl, name.c_str(), value.c_str());

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_string_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_setting_change_boolean_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_BOOLEAN_V1)(const KODI_ADDON_HDL hdl, const char* name, bool value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, bool> msgChild__IN_kodi_addon_setting_change_boolean_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_boolean_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_boolean_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      bool value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_boolean_v1(this, auto_gen_hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_boolean_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_setting_change_integer_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_INTEGER_V1)(const KODI_ADDON_HDL hdl, const char* name, int value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, int> msgChild__IN_kodi_addon_setting_change_integer_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_integer_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_integer_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      int value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_integer_v1(this, auto_gen_hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_integer_v1(auto_gen_ret));
      return true;
    }
    case funcChild_kodi_addon_setting_change_float_v1:
    {
      // Original API call: typedef enum ADDON_STATUS(ATTR_APIENTRYP PFN_KODI_ADDON_SETTING_CHANGE_FLOAT_V1)(const KODI_ADDON_HDL hdl, const char* name, float value);
      // Tuple in:          typedef std::tuple<PtrValue, std::string, float> msgChild__IN_kodi_addon_setting_change_float_v1; /* Autogenerated */
      // Tuple out:         typedef std::tuple<ADDON_STATUS> msgChild_OUT_kodi_addon_setting_change_float_v1; /* Autogenerated */

      msgChild__IN_kodi_addon_setting_change_float_v1 t = in.get().as<decltype(t)>();
      KODI_ADDON_HDL auto_gen_hdl = reinterpret_cast<KODI_ADDON_HDL>(std::get<0>(t));
      const std::string& name = std::get<1>(t);
      float value = std::get<2>(t);
      enum ADDON_STATUS auto_gen_ret =
          kodi_addon_setting_change_float_v1(this, auto_gen_hdl, name.c_str(), value);

      msgpack::pack(out, msgChild_OUT_kodi_addon_setting_change_float_v1(auto_gen_ret));
      return true;
    }
    default:
      break;
  }
  return false;
}
#endif /* !KODI_INHIBIT_SHARED */

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/

KODI::ADDONS::INTERFACE::DirectAddonIfc* kodi_check_direct_api(int argc, char* argv[])
{
  static const char* value = "--direct-api=";
  static std::string direct_api = "0";

  for (int i = 1; i < argc; ++i)
  {
    if (argv[i] == nullptr)
      break;

    std::string arg = argv[i];
    if (arg.rfind(value, 0) == 0)
    {
      direct_api = arg.substr(strlen(value));
      break;
    }
    else if ((arg == "-d") || (arg == "--direct-api"))
    {
      if (i + 1 < argc) // Make sure we aren't at the end of argv!
      {
        direct_api = argv[++i]; // Increment 'i' so we don't get the argument as the next argv[i].
        break;
      }
    }
  }

  return reinterpret_cast<KODI::ADDONS::INTERFACE::DirectAddonIfc*>(stoull(direct_api, 0, 16));
}

ATTR_DLL_EXPORT KODI_HANDLE kodi_check_for_first_instance(int argc, char* argv[])
{
  // Original API call: ATTR_DLL_EXPORT KODI_HANDLE kodi_check_for_first_instance(int argc, char* argv[]) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_check_for_first_instance - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_check_for_first_instance - Override active to use inside dev-kit library only */

  static const char* value = "--first-instance=";
  static std::string first_instance = "0";

  for (int i = 1; i < argc; ++i)
  {
    if (argv[i] == nullptr)
      break;

    std::string arg = argv[i];
    if (arg.rfind(value, 0) == 0)
    {
      first_instance = arg.substr(strlen(value));
      break;
    }
    else if ((arg == "-i") || (arg == "--first-instance"))
    {
      if (i + 1 < argc) // Make sure we aren't at the end of argv!
      {
        first_instance =
            argv[++i]; // Increment 'i' so we don't get the argument as the next argv[i].
        break;
      }
    }
  }

  return reinterpret_cast<KODI_HANDLE>(stoull(first_instance, 0, 16));
}

/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/


enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_create_v1(
    void* thisClassHdl, KODI_ADDON_HDL* hdl) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_V1_2>---*/

  ADDON_STATUS status;
  if (thisClass->m_ifc->functions.types.kodi_addon.v1.create)
  {
    status = thisClass->m_ifc->functions.types.kodi_addon.v1.create(
        thisClass->m_ifc->kodiFirstInstance, hdl);
    thisClass->m_ifc->functions.hdl = *hdl;
  }
  else
    status = ADDON_STATUS_NOT_IMPLEMENTED;
  *hdl = &thisClass->m_ifc->functions;
  return status;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_V1_2_END>---*/
}

void CHdl_kodi_addon_base_h::kodi_addon_destroy_v1(void* thisClassHdl,
                                                   KODI_ADDON_HDL hdl) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  if (union_data->types.kodi_addon.v1.destroy)
  {
    union_data->types.kodi_addon.v1.destroy(union_data->hdl);
  }
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_create_instance_v1(
    void* thisClassHdl,
    KODI_ADDON_HDL hdl,
    ADDON_INSTANCE instanceType,
    const std::string& instanceID,
    KODI_OWN_HDL instance,
    KODI_HANDLE* addonInstance,
    KODI_HANDLE parent) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1_2>---*/
  // Autogenerated by "Generate_kodi_addon_instance_construct.py", edit this for code changes!
  ADDON_STATUS status;
  UnionAddonFunctions* data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  if (data->types.kodi_addon.v1.create_instance)
  {
    UnionAddonFunctions* instanceStruct = new UnionAddonFunctions();
    instanceStruct->type = instanceType;
    instanceStruct->kodi = instance;

    KODI_INSTANCE_HDL addonIntInstance = {};
    addonIntInstance.type = instanceType;
    addonIntInstance.kodi = instance;
    addonIntInstance.kodi_first_instance = instance == thisClass->m_ifc->kodiFirstInstance;
    addonIntInstance.dummy = &instanceStruct->types.dummy;

    status = data->types.kodi_addon.v1.create_instance(data->hdl, instanceType, instanceID.c_str(),
                                                       &addonIntInstance, parent);
    if ((!addonIntInstance.dummy || addonIntInstance.type != instanceType) &&
        status == ADDON_STATUS_OK)
    {
      status = ADDON_STATUS_PERMANENT_FAILURE;
    }
    else if (addonIntInstance.dummy)
    {
      instanceStruct->type = instanceType;
      instanceStruct->addon_struct_ptr = addonIntInstance.dummy;
      if (instanceType == ADDON_INSTANCE_AUDIODECODER)
      {
        if (&instanceStruct->types.kodi_addon_audiodecoder.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audiodecoder.v1)*>(
                addonIntInstance.audiodecoder))
          instanceStruct->types.kodi_addon_audiodecoder.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audiodecoder.v1)*>(
                  addonIntInstance.audiodecoder);
        if (instanceStruct->types.kodi_addon_audiodecoder.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_audiodecoder.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_AUDIOENCODER)
      {
        if (&instanceStruct->types.kodi_addon_audioencoder.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audioencoder.v1)*>(
                addonIntInstance.audioencoder))
          instanceStruct->types.kodi_addon_audioencoder.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_audioencoder.v1)*>(
                  addonIntInstance.audioencoder);
        if (instanceStruct->types.kodi_addon_audioencoder.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_audioencoder.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_GAME)
      {
        if (&instanceStruct->types.kodi_addon_game.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_game.v1)*>(
                addonIntInstance.game))
          instanceStruct->types.kodi_addon_game.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_game.v1)*>(
                  addonIntInstance.game);
        if (instanceStruct->types.kodi_addon_game.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_game.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_IMAGEDECODER)
      {
        if (&instanceStruct->types.kodi_addon_imagedecoder.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_imagedecoder.v1)*>(
                addonIntInstance.imagedecoder))
          instanceStruct->types.kodi_addon_imagedecoder.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_imagedecoder.v1)*>(
                  addonIntInstance.imagedecoder);
        if (instanceStruct->types.kodi_addon_imagedecoder.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_imagedecoder.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_INPUTSTREAM)
      {
        if (&instanceStruct->types.kodi_addon_inputstream.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_inputstream.v1)*>(
                addonIntInstance.inputstream))
          instanceStruct->types.kodi_addon_inputstream.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_inputstream.v1)*>(
                  addonIntInstance.inputstream);
        if (instanceStruct->types.kodi_addon_inputstream.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_inputstream.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_PERIPHERAL)
      {
        if (&instanceStruct->types.kodi_addon_peripheral.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_peripheral.v1)*>(
                addonIntInstance.peripheral))
          instanceStruct->types.kodi_addon_peripheral.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_peripheral.v1)*>(
                  addonIntInstance.peripheral);
        if (instanceStruct->types.kodi_addon_peripheral.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_peripheral.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_SCREENSAVER)
      {
        if (&instanceStruct->types.kodi_addon_screensaver.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_screensaver.v1)*>(
                addonIntInstance.screensaver))
          instanceStruct->types.kodi_addon_screensaver.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_screensaver.v1)*>(
                  addonIntInstance.screensaver);
        if (instanceStruct->types.kodi_addon_screensaver.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_screensaver.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_VFS)
      {
        if (&instanceStruct->types.kodi_addon_vfs.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_vfs.v1)*>(
                addonIntInstance.vfs))
          instanceStruct->types.kodi_addon_vfs.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_vfs.v1)*>(
                  addonIntInstance.vfs);
        if (instanceStruct->types.kodi_addon_vfs.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_vfs.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_VIDEOCODEC)
      {
        if (&instanceStruct->types.kodi_addon_videocodec.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_videocodec.v1)*>(
                addonIntInstance.videocodec))
          instanceStruct->types.kodi_addon_videocodec.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_videocodec.v1)*>(
                  addonIntInstance.videocodec);
        if (instanceStruct->types.kodi_addon_videocodec.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_videocodec.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
      if (instanceType == ADDON_INSTANCE_VISUALIZATION)
      {
        if (&instanceStruct->types.kodi_addon_visualization.v1 !=
            reinterpret_cast<decltype(instanceStruct->types.kodi_addon_visualization.v1)*>(
                addonIntInstance.visualization))
          instanceStruct->types.kodi_addon_visualization.v1 =
              *reinterpret_cast<decltype(instanceStruct->types.kodi_addon_visualization.v1)*>(
                  addonIntInstance.visualization);
        if (instanceStruct->types.kodi_addon_visualization.v1.create)
          instanceStruct->hdl = instanceStruct->types.kodi_addon_visualization.v1.create(instance);
        else
          instanceStruct->hdl = addonIntInstance.instance;
        goto done;
      }
    done:
      *addonInstance = instanceStruct;
      return status;
    }

    delete instanceStruct;
  }
  else
    status = ADDON_STATUS_NOT_IMPLEMENTED;

  return status;
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_CREATE_INSTANCE_V1_2_END>---*/
}

void CHdl_kodi_addon_base_h::kodi_addon_destroy_instance_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    ADDON_INSTANCE instanceType,
    KODI_HANDLE instance) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1_2>---*/
  // Autogenerated by "Generate_kodi_addon_instance_construct.py", edit this for code changes!
  UnionAddonFunctions* data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  UnionAddonFunctions* instanceStruct = reinterpret_cast<UnionAddonFunctions*>(instance);
  if (instanceStruct)
  {
    if (instanceType == ADDON_INSTANCE_AUDIODECODER)
    {
      if (instanceStruct->types.kodi_addon_audiodecoder.v1.destroy)
        instanceStruct->types.kodi_addon_audiodecoder.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_AUDIOENCODER)
    {
      if (instanceStruct->types.kodi_addon_audioencoder.v1.destroy)
        instanceStruct->types.kodi_addon_audioencoder.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_GAME)
    {
      if (instanceStruct->types.kodi_addon_game.v1.destroy)
        instanceStruct->types.kodi_addon_game.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_IMAGEDECODER)
    {
      if (instanceStruct->types.kodi_addon_imagedecoder.v1.destroy)
        instanceStruct->types.kodi_addon_imagedecoder.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_INPUTSTREAM)
    {
      if (instanceStruct->types.kodi_addon_inputstream.v1.destroy)
        instanceStruct->types.kodi_addon_inputstream.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_PERIPHERAL)
    {
      if (instanceStruct->types.kodi_addon_peripheral.v1.destroy)
        instanceStruct->types.kodi_addon_peripheral.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_SCREENSAVER)
    {
      if (instanceStruct->types.kodi_addon_screensaver.v1.destroy)
        instanceStruct->types.kodi_addon_screensaver.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_VFS)
    {
      if (instanceStruct->types.kodi_addon_vfs.v1.destroy)
        instanceStruct->types.kodi_addon_vfs.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_VIDEOCODEC)
    {
      if (instanceStruct->types.kodi_addon_videocodec.v1.destroy)
        instanceStruct->types.kodi_addon_videocodec.v1.destroy(instanceStruct->hdl);
      goto done;
    }
    if (instanceType == ADDON_INSTANCE_VISUALIZATION)
    {
      if (instanceStruct->types.kodi_addon_visualization.v1.destroy)
        instanceStruct->types.kodi_addon_visualization.v1.destroy(instanceStruct->hdl);
      goto done;
    }
  done:
    if (data->types.kodi_addon.v1.destroy_instance)
    {
      KODI_INSTANCE_HDL addonInstance = {};
      addonInstance.kodi = instanceStruct->kodi;
      addonInstance.type = instanceType;
      addonInstance.instance = instanceStruct->hdl;
      addonInstance.dummy = instanceStruct->addon_struct_ptr;
      data->types.kodi_addon.v1.destroy_instance(data->hdl, instanceType, &addonInstance);
    }
    delete instanceStruct;
  }
  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_ADDON_DESTROY_INSTANCE_V1_2_END>---*/
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_string_v1(
    void* thisClassHdl,
    const KODI_ADDON_HDL hdl,
    const char* name,
    const char* value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_string)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_string(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_boolean_v1(
    void* thisClassHdl, const KODI_ADDON_HDL hdl, const char* name, bool value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_boolean)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_boolean(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_integer_v1(
    void* thisClassHdl, const KODI_ADDON_HDL hdl, const char* name, int value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_integer)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_integer(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

enum ADDON_STATUS CHdl_kodi_addon_base_h::kodi_addon_setting_change_float_v1(
    void* thisClassHdl, const KODI_ADDON_HDL hdl, const char* name, float value) // Added with API 1
{
  auto thisClass = reinterpret_cast<CHdl_kodi_addon_base_h*>(thisClassHdl);
  if (thisClass == nullptr)
    return ADDON_STATUS_OK;

  UnionAddonFunctions* union_data = reinterpret_cast<UnionAddonFunctions*>(hdl);
  enum ADDON_STATUS auto_gen_ret = ADDON_STATUS_OK;
  if (union_data->types.kodi_addon.v1.setting_change_float)
  {
    auto_gen_ret =
        union_data->types.kodi_addon.v1.setting_change_float(union_data->hdl, name, value);
  }
  return auto_gen_ret;
}

} /* namespace INTERNAL */
} /* namespace KODI_ADDON */

ATTR_DLL_EXPORT const char* kodi_check_main_shared(int argc, char* argv[])
{
  // Original API call: ATTR_DLL_EXPORT const char* kodi_check_main_shared(int argc, char* argv[]) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_check_main_shared - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_check_main_shared - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_CHECK_MAIN_SHARED_V1>---*/

  static const char* value = "--main-shared=";
  static std::string main_shared;

  for (int i = 1; i < argc; ++i)
  {
    if (argv[i] == nullptr)
      break;

    std::string arg = argv[i];
    if (arg.rfind(value, 0) == 0)
    {
      main_shared = arg.substr(strlen(value));
      break;
    }
    else if ((arg == "-m") || (arg == "--main-shared"))
    {
      if (i + 1 < argc) // Make sure we aren't at the end of argv!
      {
        main_shared = argv[++i]; // Increment 'i' so we don't get the argument as the next argv[i].
        break;
      }
    }
  }

  return main_shared.c_str();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_CHECK_MAIN_SHARED_V1_END>---*/
}

ATTR_DLL_EXPORT KODI_IFC_HDL kodi_init(unsigned int api,
                                       int argc,
                                       char* argv[],
                                       struct KODI_ADDON_FUNC* func,
                                       bool via_main,
                                       bool no_receive)
{
  // Original API call: ATTR_DLL_EXPORT KODI_IFC_HDL kodi_init(unsigned int api, int argc, char* argv[], struct KODI_ADDON_FUNC* func, bool via_main, bool no_receive) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_init - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_init - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_INIT_V1>---*/

  if (AddonIfc::g_ifc)
  {
    fprintf(stderr, R"error(
FATAL: This class "CChildProcessor" should only be used one time in App.
       Here becomes a second time called and child app becomes destroyed now.
       Inform developer about this addon to fix it!
    )error");
    exit(1);
  }

  KODI_ADDON::INTERNAL::AddonIfc* ifc = new AddonIfc();
  ifc->api = api;
  ifc->identifier = kodi_check_main_shared(argc, argv);
  if (ifc->identifier.empty())
  {
    fprintf(stderr, "FATAL: Started addon without valid identifier, Addon not usable!\n");
    exit(1);
  }

  ifc->kodiFirstInstance = kodi_check_for_first_instance(argc, argv);
  ifc->direct = kodi_check_direct_api(argc, argv);
  if (ifc->direct)
    ifc->direct_used = true;

  if (func)
    ifc->functions.types.kodi_addon.v1 =
        *reinterpret_cast<decltype(ifc->functions.types.kodi_addon.v1)*>(func);
  ifc->viaMainThread = via_main;
  ifc->noReceive = no_receive;
  ifc->control = std::unique_ptr<CAddonControl>(new CAddonControl(ifc));
  if (!ifc->control->Create())
  {
    fprintf(stderr, "FATAL: Started addon without valid identifier, Addon not usable!\n");
    delete ifc;
    exit(1);
  }

  AddonIfc::g_ifc = ifc;
  return AddonIfc::g_ifc;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_INIT_V1_END>---*/
}

ATTR_DLL_EXPORT void kodi_deinit(KODI_IFC_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_deinit(KODI_IFC_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_deinit - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_deinit - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_DEINIT_V1>---*/

  if (!AddonIfc::g_ifc)
    return;

  delete AddonIfc::g_ifc;
  AddonIfc::g_ifc = nullptr;

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_DEINIT_V1_END>---*/
}

ATTR_DLL_EXPORT bool kodi_process(KODI_IFC_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_process(KODI_IFC_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_process - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_process - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_PROCESS_V1>---*/

  if (!AddonIfc::g_ifc)
    return false;
  return AddonIfc::g_ifc->control->ProcessOutside();

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_PROCESS_V1_END>---*/
}

ATTR_DLL_EXPORT void kodi_log(enum ADDON_LOG loglevel, const char* format, ...)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_log(enum ADDON_LOG loglevel, const char* format, ...) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<ADDON_LOG, std::string> msgParent__IN_kodi_log_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_log_v1; /* Autogenerated */

  if (format == nullptr)
    return;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    va_list args;
    va_start(args, format);
    const std::string cpp_format = kodi::tools::StringUtils::FormatV(format, args);
    va_end(args);
    msgpack::sbuffer in;
    msgpack::pack(in, msgParent__IN_kodi_log_v1(loglevel, cpp_format));
    AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(funcGroup_addon_base_h,
                                                          funcParent_kodi_log_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  auto_gen_group.kodi_log_v1(auto_gen_group.thisClassHdl, loglevel, format);
}

ATTR_DLL_EXPORT char* kodi_addon_get_lib_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_lib_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_lib_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_lib_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_lib_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_lib_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_lib_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_share_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_share_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_share_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_share_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_share_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_share_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_share_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_user_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_user_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_user_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_user_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_user_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_user_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_user_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_temp_path()
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_temp_path() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_get_temp_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_temp_path_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_temp_path_v1, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_temp_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_temp_path_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT char* kodi_addon_get_info(const char* id)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_addon_get_info(const char* id) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_get_info_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_addon_get_info_v1; /* Autogenerated */

  if (id == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_info_v1(id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_info_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_info_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_info_v1(auto_gen_group.thisClassHdl, id);
}

ATTR_DLL_EXPORT bool kodi_addon_open_settings_dialog()
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_open_settings_dialog() __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<DummyValue> msgParent__IN_kodi_addon_open_settings_dialog_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_open_settings_dialog_v1; /* Autogenerated */

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer out;
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessageOnlyGetReturn(
            funcGroup_addon_base_h, funcParent_kodi_addon_open_settings_dialog_v1, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_open_settings_dialog_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_open_settings_dialog_v1(auto_gen_group.thisClassHdl);
}

ATTR_DLL_EXPORT bool kodi_addon_is_setting_using_default(const char* id)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_is_setting_using_default(const char* id) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_is_setting_using_default_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_is_setting_using_default_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_is_setting_using_default_v1(id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_is_setting_using_default_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_is_setting_using_default_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_is_setting_using_default_v1(auto_gen_group.thisClassHdl, id);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_bool(const char* id, bool* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_bool(const char* id, bool* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_addon_get_setting_bool_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, bool> msgParent_OUT_kodi_addon_get_setting_bool_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_bool_v1(id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_bool_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_bool_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_bool_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_int(const char* id, int* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_int(const char* id, int* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, int> msgParent__IN_kodi_addon_get_setting_int_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, int> msgParent_OUT_kodi_addon_get_setting_int_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_int_v1(id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_int_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_int_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_int_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_float(const char* id, float* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_float(const char* id, float* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, float> msgParent__IN_kodi_addon_get_setting_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, float> msgParent_OUT_kodi_addon_get_setting_float_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_float_v1(id, *value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_float_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_float_v1 t = ident.get().as<decltype(t)>();

    *value = std::get<1>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_float_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_get_setting_string(const char* id, char** value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_get_setting_string(const char* id, char** value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_addon_get_setting_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_addon_get_setting_string_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_get_setting_string_v1(id));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_get_setting_string_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_get_setting_string_v1 t = ident.get().as<decltype(t)>();

    *value = strdup(std::get<1>(t).c_str());
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_get_setting_string_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_bool(const char* id, bool value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_bool(const char* id, bool value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_addon_set_setting_bool_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_bool_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_bool_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_bool_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_bool_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_bool_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_int(const char* id, int value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_int(const char* id, int value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, int> msgParent__IN_kodi_addon_set_setting_int_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_int_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_int_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_int_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_int_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_int_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_float(const char* id, float value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_float(const char* id, float value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, float> msgParent__IN_kodi_addon_set_setting_float_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_float_v1; /* Autogenerated */

  if (id == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_float_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_float_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_float_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_float_v1(auto_gen_group.thisClassHdl, id, value);
}

ATTR_DLL_EXPORT bool kodi_addon_set_setting_string(const char* id, const char* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_addon_set_setting_string(const char* id, const char* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_addon_set_setting_string_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_addon_set_setting_string_v1; /* Autogenerated */

  if (id == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_addon_set_setting_string_v1(id, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_addon_base_h, funcParent_kodi_addon_set_setting_string_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_addon_set_setting_string_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.addon_base_h;
  return auto_gen_group.kodi_addon_set_setting_string_v1(auto_gen_group.thisClassHdl, id, value);
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_4>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_4_END>---*/
