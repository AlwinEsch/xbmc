/*
 *  Copyright (C) 2005-2021 Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */

#include "filesystem.h"

// Shared API
#include "src/shared/Instances.h"

// Lib code
#include "core/addon_control.h"

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_1_END>---*/

using namespace KODI::ADDONS::INTERFACE;
using namespace KODI_ADDON::INTERNAL;

namespace KODI_ADDON
{
namespace INTERNAL
{

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_2_END>---*/

void CHdl_kodi_filesystem_h::InitDirect(directFuncToAddon_filesystem_h* ifcToAddon)
{
  ifcToAddon->thisClassHdl = this;
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_3_END>---*/

/* NOTE: unused (no functions from Kodi to addon here) */

} /* namespace INTERNAL */
} /* namespace KODI_ADDON */

ATTR_DLL_EXPORT bool kodi_vfs_can_open_directory(const char* url)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_can_open_directory(const char* url) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_can_open_directory_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_can_open_directory_v1; /* Autogenerated */

  if (url == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_can_open_directory_v1(url));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_can_open_directory_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_can_open_directory_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_can_open_directory_v1(auto_gen_group.thisClassHdl, url);
}

ATTR_DLL_EXPORT bool kodi_vfs_create_directory(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_create_directory(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_create_directory_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_create_directory_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_create_directory_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_create_directory_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_create_directory_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_create_directory_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_remove_directory(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_remove_directory(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_remove_directory_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_remove_directory_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_remove_directory_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_remove_directory_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_remove_directory_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_remove_directory_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_remove_directory_recursive(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_remove_directory_recursive(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_remove_directory_recursive_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_remove_directory_recursive_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_remove_directory_recursive_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_remove_directory_recursive_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_remove_directory_recursive_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_remove_directory_recursive_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_directory_exists(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_directory_exists(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_directory_exists_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_directory_exists_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_directory_exists_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_directory_exists_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_directory_exists_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_directory_exists_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_get_directory(const char* path,
                                            const char* mask,
                                            struct VFS_DIR_ENTRY** items,
                                            size_t* num_items)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_directory(const char* path, const char* mask, struct VFS_DIR_ENTRY** items, size_t* num_items) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string, size_t> msgParent__IN_kodi_vfs_get_directory_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::vector<IFC_VFS_DIR_ENTRY>, size_t> msgParent_OUT_kodi_vfs_get_directory_v1; /* Autogenerated */

  if (path == nullptr || mask == nullptr || items == nullptr || num_items == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_directory_v1(path, mask, *num_items));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_directory_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_directory_v1 t = ident.get().as<decltype(t)>();

    std::vector<IFC_VFS_DIR_ENTRY>& ifc_items = std::get<1>(t);
    *num_items = std::get<2>(t);
    *items = static_cast<VFS_DIR_ENTRY*>(malloc(sizeof(VFS_DIR_ENTRY) * ifc_items.size()));
    for (size_t i = 0; i < ifc_items.size(); ++i)
      ifc_items[i].SetCStructure(&(*items)[i]);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_directory_v1(auto_gen_group.thisClassHdl, path, mask, items,
                                                  num_items);
}

ATTR_DLL_EXPORT void kodi_vfs_free_directory(struct VFS_DIR_ENTRY* items, size_t num_items)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_vfs_free_directory(struct VFS_DIR_ENTRY* items, size_t num_items) __INTRODUCED_IN_KODI(1);
  // Tuple in:          /* NOTE: msgParent__IN_kodi_vfs_free_directory - Override active to use inside dev-kit library only */
  // Tuple out:         /* NOTE: msgParent_OUT_kodi_vfs_free_directory - Override active to use inside dev-kit library only */

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FREE_DIRECTORY_V1>---*/

  for (unsigned int i = 0; i < num_items; ++i)
  {
    if (items[i].label)
    {
      free(items[i].label);
      items[i].label = nullptr;
    }
    if (items[i].title)
    {
      free(items[i].title);
      items[i].title = nullptr;
    }
    if (items[i].path)
    {
      free(items[i].path);
      items[i].path = nullptr;
    }
    if (items[i].properties)
    {
      free(items[i].properties);
      items[i].properties = nullptr;
    }
  }
  free(items);

  /*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_KODI_VFS_FREE_DIRECTORY_V1_END>---*/
}

ATTR_DLL_EXPORT bool kodi_vfs_file_exists(const char* filename, bool useCache)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_exists(const char* filename, bool useCache) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_vfs_file_exists_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_exists_v1; /* Autogenerated */

  if (filename == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_exists_v1(filename, useCache));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_exists_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_exists_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_exists_v1(auto_gen_group.thisClassHdl, filename, useCache);
}

ATTR_DLL_EXPORT bool kodi_vfs_stat_file(const char* filename, struct VFS_STAT_STRUCTURE* buffer)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_stat_file(const char* filename, struct VFS_STAT_STRUCTURE* buffer) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_stat_file_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, IFC_VFS_STAT_STRUCTURE> msgParent_OUT_kodi_vfs_stat_file_v1; /* Autogenerated */

  if (filename == nullptr || buffer == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_stat_file_v1(filename));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_stat_file_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_stat_file_v1 t = ident.get().as<decltype(t)>();

    std::get<1>(t).SetCStructure(buffer);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_stat_file_v1(auto_gen_group.thisClassHdl, filename, buffer);
}

ATTR_DLL_EXPORT bool kodi_vfs_delete_file(const char* filename)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_delete_file(const char* filename) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_delete_file_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_delete_file_v1; /* Autogenerated */

  if (filename == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_delete_file_v1(filename));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_delete_file_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_delete_file_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_delete_file_v1(auto_gen_group.thisClassHdl, filename);
}

ATTR_DLL_EXPORT bool kodi_vfs_rename_file(const char* filename, const char* newFileName)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_rename_file(const char* filename, const char* newFileName) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_rename_file_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_rename_file_v1; /* Autogenerated */

  if (filename == nullptr || newFileName == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_rename_file_v1(filename, newFileName));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_rename_file_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_rename_file_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_rename_file_v1(auto_gen_group.thisClassHdl, filename, newFileName);
}

ATTR_DLL_EXPORT bool kodi_vfs_copy_file(const char* filename, const char* dest)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_copy_file(const char* filename, const char* dest) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_copy_file_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_copy_file_v1; /* Autogenerated */

  if (filename == nullptr || dest == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_copy_file_v1(filename, dest));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_copy_file_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_copy_file_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_copy_file_v1(auto_gen_group.thisClassHdl, filename, dest);
}

ATTR_DLL_EXPORT char* kodi_vfs_get_file_md5(const char* filename)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_get_file_md5(const char* filename) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_get_file_md5_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_get_file_md5_v1; /* Autogenerated */

  if (filename == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_file_md5_v1(filename));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_file_md5_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_file_md5_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_file_md5_v1(auto_gen_group.thisClassHdl, filename);
}

ATTR_DLL_EXPORT char* kodi_vfs_get_cache_thumb_name(const char* filename)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_get_cache_thumb_name(const char* filename) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_get_cache_thumb_name_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_get_cache_thumb_name_v1; /* Autogenerated */

  if (filename == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_cache_thumb_name_v1(filename));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_cache_thumb_name_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_cache_thumb_name_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_cache_thumb_name_v1(auto_gen_group.thisClassHdl, filename);
}

ATTR_DLL_EXPORT char* kodi_vfs_make_legal_filename(const char* filename)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_make_legal_filename(const char* filename) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_make_legal_filename_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_make_legal_filename_v1; /* Autogenerated */

  if (filename == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_make_legal_filename_v1(filename));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_make_legal_filename_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_make_legal_filename_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_make_legal_filename_v1(auto_gen_group.thisClassHdl, filename);
}

ATTR_DLL_EXPORT char* kodi_vfs_make_legal_path(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_make_legal_path(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_make_legal_path_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_make_legal_path_v1; /* Autogenerated */

  if (path == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_make_legal_path_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_make_legal_path_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_make_legal_path_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_make_legal_path_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT char* kodi_vfs_translate_special_protocol(const char* strSource)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_translate_special_protocol(const char* strSource) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_translate_special_protocol_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_translate_special_protocol_v1; /* Autogenerated */

  if (strSource == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_translate_special_protocol_v1(strSource));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_translate_special_protocol_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_translate_special_protocol_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_translate_special_protocol_v1(auto_gen_group.thisClassHdl,
                                                               strSource);
}

ATTR_DLL_EXPORT bool kodi_vfs_is_internet_stream(const char* path, bool strictCheck)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_internet_stream(const char* path, bool strictCheck) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_vfs_is_internet_stream_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_internet_stream_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_is_internet_stream_v1(path, strictCheck));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_is_internet_stream_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_is_internet_stream_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_is_internet_stream_v1(auto_gen_group.thisClassHdl, path,
                                                       strictCheck);
}

ATTR_DLL_EXPORT bool kodi_vfs_is_on_lan(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_on_lan(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_on_lan_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_on_lan_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_is_on_lan_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_is_on_lan_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_is_on_lan_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_is_on_lan_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_is_remote(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_remote(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_remote_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_remote_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_is_remote_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_is_remote_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_is_remote_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_is_remote_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_is_local(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_local(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_local_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_local_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_is_local_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_is_local_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_is_local_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_is_local_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_is_url(const char* path)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_is_url(const char* path) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_is_url_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_is_url_v1; /* Autogenerated */

  if (path == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_is_url_v1(path));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_is_url_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_is_url_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_is_url_v1(auto_gen_group.thisClassHdl, path);
}

ATTR_DLL_EXPORT bool kodi_vfs_get_mime_type(const char* url, char** content, const char* useragent)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_mime_type(const char* url, char** content, const char* useragent) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_get_mime_type_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_get_mime_type_v1; /* Autogenerated */

  if (url == nullptr || content == nullptr || useragent == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_mime_type_v1(url, useragent));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_mime_type_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_mime_type_v1 t = ident.get().as<decltype(t)>();

    *content = strdup(std::get<1>(t).c_str());
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_mime_type_v1(auto_gen_group.thisClassHdl, url, content,
                                                  useragent);
}

ATTR_DLL_EXPORT bool kodi_vfs_get_content_type(const char* url,
                                               char** content,
                                               const char* useragent)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_content_type(const char* url, char** content, const char* useragent) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, std::string> msgParent__IN_kodi_vfs_get_content_type_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_get_content_type_v1; /* Autogenerated */

  if (url == nullptr || content == nullptr || useragent == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_content_type_v1(url, useragent));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_content_type_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_content_type_v1 t = ident.get().as<decltype(t)>();

    *content = strdup(std::get<1>(t).c_str());
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_content_type_v1(auto_gen_group.thisClassHdl, url, content,
                                                     useragent);
}

ATTR_DLL_EXPORT bool kodi_vfs_get_cookies(const char* url, char** cookies)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_cookies(const char* url, char** cookies) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_get_cookies_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_get_cookies_v1; /* Autogenerated */

  if (url == nullptr || cookies == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_cookies_v1(url));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_cookies_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_cookies_v1 t = ident.get().as<decltype(t)>();

    *cookies = strdup(std::get<1>(t).c_str());
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_cookies_v1(auto_gen_group.thisClassHdl, url, cookies);
}

ATTR_DLL_EXPORT bool kodi_vfs_get_disk_space(const char* path,
                                             uint64_t* capacity,
                                             uint64_t* free,
                                             uint64_t* available)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_get_disk_space(const char* path, uint64_t* capacity, uint64_t* free, uint64_t* available) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, uint64_t, uint64_t, uint64_t> msgParent__IN_kodi_vfs_get_disk_space_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, uint64_t, uint64_t, uint64_t> msgParent_OUT_kodi_vfs_get_disk_space_v1; /* Autogenerated */

  if (path == nullptr || capacity == nullptr || free == nullptr || available == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_get_disk_space_v1(path, *capacity, *free, *available));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_get_disk_space_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_get_disk_space_v1 t = ident.get().as<decltype(t)>();

    *capacity = std::get<1>(t);
    *free = std::get<2>(t);
    *available = std::get<3>(t);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_get_disk_space_v1(auto_gen_group.thisClassHdl, path, capacity,
                                                   free, available);
}

ATTR_DLL_EXPORT KODI_HTTP_HEADER_HDL kodi_vfs_http_header_open(const char* url)
{
  // Original API call: ATTR_DLL_EXPORT KODI_HTTP_HEADER_HDL kodi_vfs_http_header_open(const char* url) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_http_header_open_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_http_header_open_v1; /* Autogenerated */

  if (url == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_open_v1(url));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_open_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_open_v1 t = ident.get().as<decltype(t)>();

    return reinterpret_cast<KODI_HTTP_HEADER_HDL>(std::get<0>(t));
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_open_v1(auto_gen_group.thisClassHdl, url);
}

ATTR_DLL_EXPORT void kodi_vfs_http_header_close(KODI_HTTP_HEADER_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_vfs_http_header_close(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_close_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_vfs_http_header_close_v1; /* Autogenerated */

  if (hdl == nullptr)
    return;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_close_v1(PtrValue(hdl)));
    AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
        funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_close_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  auto_gen_group.kodi_vfs_http_header_close_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_value(KODI_HTTP_HEADER_HDL hdl, const char* param)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_value(KODI_HTTP_HEADER_HDL hdl, const char* param) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string> msgParent__IN_kodi_vfs_http_header_get_value_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_value_v1; /* Autogenerated */

  if (hdl == nullptr || param == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_get_value_v1(PtrValue(hdl), param));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_get_value_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_get_value_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_get_value_v1(auto_gen_group.thisClassHdl, hdl, param);
}

ATTR_DLL_EXPORT char** kodi_vfs_http_header_get_values(KODI_HTTP_HEADER_HDL hdl,
                                                       const char* param,
                                                       size_t* length)
{
  // Original API call: ATTR_DLL_EXPORT char** kodi_vfs_http_header_get_values(KODI_HTTP_HEADER_HDL hdl, const char* param, size_t* length) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::string, size_t> msgParent__IN_kodi_vfs_http_header_get_values_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::vector<std::string>, size_t> msgParent_OUT_kodi_vfs_http_header_get_values_v1; /* Autogenerated */

  if (hdl == nullptr || param == nullptr || length == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_vfs_http_header_get_values_v1(PtrValue(hdl), param, *length));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_get_values_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_get_values_v1 t = ident.get().as<decltype(t)>();

    *length = std::get<1>(t);
    const std::vector<std::string>& values = std::get<0>(t);
    char** ret = static_cast<char**>(malloc(sizeof(char*) * values.size()));
    for (size_t i = 0; i < *length; ++i)
    {
      ret[i] = strdup(values[i].c_str());
    }
    return ret;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_get_values_v1(auto_gen_group.thisClassHdl, hdl, param,
                                                           length);
}

ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_header(KODI_HTTP_HEADER_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_header(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_header_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_header_v1; /* Autogenerated */

  if (hdl == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_get_header_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_get_header_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_get_header_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_get_header_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_mime_type(KODI_HTTP_HEADER_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_mime_type(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_mime_type_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_mime_type_v1; /* Autogenerated */

  if (hdl == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_get_mime_type_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_get_mime_type_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_get_mime_type_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_get_mime_type_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_charset(KODI_HTTP_HEADER_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_charset(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_charset_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_charset_v1; /* Autogenerated */

  if (hdl == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_get_charset_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_get_charset_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_get_charset_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_get_charset_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_proto_line(KODI_HTTP_HEADER_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_http_header_get_proto_line(KODI_HTTP_HEADER_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_http_header_get_proto_line_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_http_header_get_proto_line_v1; /* Autogenerated */

  if (hdl == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_http_header_get_proto_line_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_http_header_get_proto_line_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_http_header_get_proto_line_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_http_header_get_proto_line_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_open(const char* filename, unsigned int flags)
{
  // Original API call: ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_open(const char* filename, unsigned int flags) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, unsigned int> msgParent__IN_kodi_vfs_file_open_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_file_open_v1; /* Autogenerated */

  if (filename == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_open_v1(filename, flags));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_open_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_open_v1 t = ident.get().as<decltype(t)>();

    return reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_open_v1(auto_gen_group.thisClassHdl, filename, flags);
}

ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_open_for_write(const char* filename, bool overwrite)
{
  // Original API call: ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_open_for_write(const char* filename, bool overwrite) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string, bool> msgParent__IN_kodi_vfs_file_open_for_write_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_file_open_for_write_v1; /* Autogenerated */

  if (filename == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_open_for_write_v1(filename, overwrite));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_open_for_write_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_open_for_write_v1 t = ident.get().as<decltype(t)>();

    return reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_open_for_write_v1(auto_gen_group.thisClassHdl, filename,
                                                        overwrite);
}

ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_curl_create(const char* url)
{
  // Original API call: ATTR_DLL_EXPORT KODI_FILE_HDL kodi_vfs_file_curl_create(const char* url) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<std::string> msgParent__IN_kodi_vfs_file_curl_create_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<PtrValue> msgParent_OUT_kodi_vfs_file_curl_create_v1; /* Autogenerated */

  if (url == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_curl_create_v1(url));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_curl_create_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_curl_create_v1 t = ident.get().as<decltype(t)>();

    return reinterpret_cast<KODI_FILE_HDL>(std::get<0>(t));
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_curl_create_v1(auto_gen_group.thisClassHdl, url);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_curl_add_option(KODI_FILE_HDL hdl,
                                                   enum CURLOptiontype type,
                                                   const char* name,
                                                   const char* value)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_curl_add_option(KODI_FILE_HDL hdl, enum CURLOptiontype type, const char* name, const char* value) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, CURLOptiontype, std::string, std::string> msgParent__IN_kodi_vfs_file_curl_add_option_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_curl_add_option_v1; /* Autogenerated */

  if (hdl == nullptr || name == nullptr || value == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in,
                  msgParent__IN_kodi_vfs_file_curl_add_option_v1(PtrValue(hdl), type, name, value));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_curl_add_option_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_curl_add_option_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_curl_add_option_v1(auto_gen_group.thisClassHdl, hdl, type,
                                                         name, value);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_curl_open(KODI_FILE_HDL hdl, unsigned int flags)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_curl_open(KODI_FILE_HDL hdl, unsigned int flags) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, unsigned int> msgParent__IN_kodi_vfs_file_curl_open_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_curl_open_v1; /* Autogenerated */

  if (hdl == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_curl_open_v1(PtrValue(hdl), flags));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_curl_open_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_curl_open_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_curl_open_v1(auto_gen_group.thisClassHdl, hdl, flags);
}

ATTR_DLL_EXPORT void kodi_vfs_file_close(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_vfs_file_close(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_close_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_vfs_file_close_v1; /* Autogenerated */

  if (hdl == nullptr)
    return;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_close_v1(PtrValue(hdl)));
    AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(funcGroup_filesystem_h,
                                                          funcParent_kodi_vfs_file_close_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  auto_gen_group.kodi_vfs_file_close_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT ssize_t kodi_vfs_file_read(KODI_FILE_HDL hdl, uint8_t* ptr, size_t size)
{
  // Original API call: ATTR_DLL_EXPORT ssize_t kodi_vfs_file_read(KODI_FILE_HDL hdl, uint8_t* ptr, size_t size) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, size_t> msgParent__IN_kodi_vfs_file_read_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ssize_t, std::vector<uint8_t>> msgParent_OUT_kodi_vfs_file_read_v1; /* Autogenerated */

  if (hdl == nullptr || ptr == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_read_v1(PtrValue(hdl), size));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_read_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_read_v1 t = ident.get().as<decltype(t)>();

    std::memcpy(ptr, std::get<1>(t).data(), sizeof(uint8_t) * size);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_read_v1(auto_gen_group.thisClassHdl, hdl, ptr, size);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_read_line(KODI_FILE_HDL hdl, char* szLine, size_t lineLength)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_read_line(KODI_FILE_HDL hdl, char* szLine, size_t lineLength) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, size_t> msgParent__IN_kodi_vfs_file_read_line_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, std::string> msgParent_OUT_kodi_vfs_file_read_line_v1; /* Autogenerated */

  if (hdl == nullptr || szLine == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_read_line_v1(PtrValue(hdl), lineLength));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_read_line_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_read_line_v1 t = ident.get().as<decltype(t)>();

    strncpy(szLine, std::get<1>(t).c_str(), lineLength);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_read_line_v1(auto_gen_group.thisClassHdl, hdl, szLine,
                                                   lineLength);
}

ATTR_DLL_EXPORT ssize_t kodi_vfs_file_write(KODI_FILE_HDL hdl, const uint8_t* ptr, size_t size)
{
  // Original API call: ATTR_DLL_EXPORT ssize_t kodi_vfs_file_write(KODI_FILE_HDL hdl, const uint8_t* ptr, size_t size) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, std::vector<uint8_t>, size_t> msgParent__IN_kodi_vfs_file_write_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<ssize_t> msgParent_OUT_kodi_vfs_file_write_v1; /* Autogenerated */

  if (hdl == nullptr || ptr == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_write_v1(
                          PtrValue(hdl), std::vector<uint8_t>(ptr, ptr + size), size));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_write_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_write_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_write_v1(auto_gen_group.thisClassHdl, hdl, ptr, size);
}

ATTR_DLL_EXPORT void kodi_vfs_file_flush(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT void kodi_vfs_file_flush(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_flush_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<DummyValue> msgParent_OUT_kodi_vfs_file_flush_v1; /* Autogenerated */

  if (hdl == nullptr)
    return;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_flush_v1(PtrValue(hdl)));
    AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(funcGroup_filesystem_h,
                                                          funcParent_kodi_vfs_file_flush_v1, in);
    return;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  auto_gen_group.kodi_vfs_file_flush_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT int64_t kodi_vfs_file_seek(KODI_FILE_HDL hdl, int64_t position, int whence)
{
  // Original API call: ATTR_DLL_EXPORT int64_t kodi_vfs_file_seek(KODI_FILE_HDL hdl, int64_t position, int whence) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, int64_t, int> msgParent__IN_kodi_vfs_file_seek_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<int64_t> msgParent_OUT_kodi_vfs_file_seek_v1; /* Autogenerated */

  if (hdl == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_seek_v1(PtrValue(hdl), position, whence));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_seek_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_seek_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_seek_v1(auto_gen_group.thisClassHdl, hdl, position, whence);
}

ATTR_DLL_EXPORT int kodi_vfs_file_truncate(KODI_FILE_HDL hdl, int64_t size)
{
  // Original API call: ATTR_DLL_EXPORT int kodi_vfs_file_truncate(KODI_FILE_HDL hdl, int64_t size) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, int64_t> msgParent__IN_kodi_vfs_file_truncate_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_vfs_file_truncate_v1; /* Autogenerated */

  if (hdl == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_truncate_v1(PtrValue(hdl), size));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_truncate_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_truncate_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_truncate_v1(auto_gen_group.thisClassHdl, hdl, size);
}

ATTR_DLL_EXPORT int64_t kodi_vfs_file_get_position(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT int64_t kodi_vfs_file_get_position(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_position_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<int64_t> msgParent_OUT_kodi_vfs_file_get_position_v1; /* Autogenerated */

  if (hdl == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_get_position_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_get_position_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_get_position_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_get_position_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT int64_t kodi_vfs_file_get_length(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT int64_t kodi_vfs_file_get_length(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_length_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<int64_t> msgParent_OUT_kodi_vfs_file_get_length_v1; /* Autogenerated */

  if (hdl == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_get_length_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_get_length_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_get_length_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_get_length_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_at_end(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_at_end(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_at_end_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_at_end_v1; /* Autogenerated */

  if (hdl == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_at_end_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_at_end_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_at_end_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_at_end_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT double kodi_vfs_file_get_download_speed(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT double kodi_vfs_file_get_download_speed(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_download_speed_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<double> msgParent_OUT_kodi_vfs_file_get_download_speed_v1; /* Autogenerated */

  if (hdl == nullptr)
    return 0.0;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_get_download_speed_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_get_download_speed_v1, in, out))
      return 0.0;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_get_download_speed_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_get_download_speed_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT int kodi_vfs_file_get_chunk_size(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT int kodi_vfs_file_get_chunk_size(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_get_chunk_size_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<int> msgParent_OUT_kodi_vfs_file_get_chunk_size_v1; /* Autogenerated */

  if (hdl == nullptr)
    return -1;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_get_chunk_size_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_get_chunk_size_v1, in, out))
      return -1;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_get_chunk_size_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_get_chunk_size_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_get_seek_possible(KODI_FILE_HDL hdl)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_get_seek_possible(KODI_FILE_HDL hdl) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_io_ctl_get_seek_possible_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_io_ctl_get_seek_possible_v1; /* Autogenerated */

  if (hdl == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_io_ctl_get_seek_possible_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_io_ctl_get_seek_possible_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_io_ctl_get_seek_possible_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_io_ctl_get_seek_possible_v1(auto_gen_group.thisClassHdl, hdl);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_get_cache_status(KODI_FILE_HDL hdl,
                                                           struct VFS_CACHE_STATUS* status)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_get_cache_status(KODI_FILE_HDL hdl, struct VFS_CACHE_STATUS* status) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue> msgParent__IN_kodi_vfs_file_io_ctl_get_cache_status_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool, IFC_VFS_CACHE_STATUS> msgParent_OUT_kodi_vfs_file_io_ctl_get_cache_status_v1; /* Autogenerated */

  if (hdl == nullptr || status == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_io_ctl_get_cache_status_v1(PtrValue(hdl)));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_io_ctl_get_cache_status_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_io_ctl_get_cache_status_v1 t = ident.get().as<decltype(t)>();

    std::get<1>(t).SetCStructure(status);
    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_io_ctl_get_cache_status_v1(auto_gen_group.thisClassHdl, hdl,
                                                                 status);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_set_cache_rate(KODI_FILE_HDL hdl, unsigned int rate)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_set_cache_rate(KODI_FILE_HDL hdl, unsigned int rate) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, unsigned int> msgParent__IN_kodi_vfs_file_io_ctl_set_cache_rate_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_io_ctl_set_cache_rate_v1; /* Autogenerated */

  if (hdl == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_io_ctl_set_cache_rate_v1(PtrValue(hdl), rate));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_io_ctl_set_cache_rate_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_io_ctl_set_cache_rate_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_io_ctl_set_cache_rate_v1(auto_gen_group.thisClassHdl, hdl,
                                                               rate);
}

ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_set_retry(KODI_FILE_HDL hdl, bool retry)
{
  // Original API call: ATTR_DLL_EXPORT bool kodi_vfs_file_io_ctl_set_retry(KODI_FILE_HDL hdl, bool retry) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, bool> msgParent__IN_kodi_vfs_file_io_ctl_set_retry_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<bool> msgParent_OUT_kodi_vfs_file_io_ctl_set_retry_v1; /* Autogenerated */

  if (hdl == nullptr)
    return false;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_io_ctl_set_retry_v1(PtrValue(hdl), retry));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_io_ctl_set_retry_v1, in, out))
      return false;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_io_ctl_set_retry_v1 t = ident.get().as<decltype(t)>();

    return std::get<0>(t);
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_io_ctl_set_retry_v1(auto_gen_group.thisClassHdl, hdl, retry);
}

ATTR_DLL_EXPORT char* kodi_vfs_file_get_property_value(KODI_FILE_HDL hdl,
                                                       enum FilePropertyTypes type,
                                                       const char* name)
{
  // Original API call: ATTR_DLL_EXPORT char* kodi_vfs_file_get_property_value(KODI_FILE_HDL hdl, enum FilePropertyTypes type, const char* name) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, FilePropertyTypes, std::string> msgParent__IN_kodi_vfs_file_get_property_value_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::string> msgParent_OUT_kodi_vfs_file_get_property_value_v1; /* Autogenerated */

  if (hdl == nullptr || name == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(in, msgParent__IN_kodi_vfs_file_get_property_value_v1(PtrValue(hdl), type, name));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_get_property_value_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_get_property_value_v1 t = ident.get().as<decltype(t)>();

    return strdup(std::get<0>(t).c_str());
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_get_property_value_v1(auto_gen_group.thisClassHdl, hdl, type,
                                                            name);
}

ATTR_DLL_EXPORT char** kodi_vfs_file_get_property_values(KODI_FILE_HDL hdl,
                                                         enum FilePropertyTypes type,
                                                         const char* name,
                                                         size_t* length)
{
  // Original API call: ATTR_DLL_EXPORT char** kodi_vfs_file_get_property_values(KODI_FILE_HDL hdl, enum FilePropertyTypes type, const char* name, size_t* length) __INTRODUCED_IN_KODI(1);
  // Tuple in:          typedef std::tuple<PtrValue, FilePropertyTypes, std::string, size_t> msgParent__IN_kodi_vfs_file_get_property_values_v1; /* Autogenerated */
  // Tuple out:         typedef std::tuple<std::vector<std::string>, size_t> msgParent_OUT_kodi_vfs_file_get_property_values_v1; /* Autogenerated */

  if (hdl == nullptr || name == nullptr || length == nullptr)
    return nullptr;

#ifndef KODI_INHIBIT_SHARED
  if (!AddonIfc::g_ifc->direct_used)
  {
    msgpack::sbuffer in;
    msgpack::sbuffer out;
    msgpack::pack(
        in, msgParent__IN_kodi_vfs_file_get_property_values_v1(PtrValue(hdl), type, name, *length));
    if (!AddonIfc::g_ifc->control->GetThreadIfc()->SendMessage(
            funcGroup_filesystem_h, funcParent_kodi_vfs_file_get_property_values_v1, in, out))
      return nullptr;
    msgpack::unpacked ident = msgpack::unpack(out.data(), out.size());
    msgParent_OUT_kodi_vfs_file_get_property_values_v1 t = ident.get().as<decltype(t)>();

    *length = std::get<1>(t);
    const std::vector<std::string>& values = std::get<0>(t);
    char** ret = static_cast<char**>(malloc(sizeof(char*) * values.size()));
    for (size_t i = 0; i < *length; ++i)
    {
      ret[i] = strdup(values[i].c_str());
    }
    return ret;
  }
#endif /* !KODI_INHIBIT_SHARED */

  const auto& auto_gen_group = AddonIfc::g_ifc->direct->to_kodi.filesystem_h;
  return auto_gen_group.kodi_vfs_file_get_property_values_v1(auto_gen_group.thisClassHdl, hdl, type,
                                                             name, length);
}

/* Code below becomes on auto generation reused, hand edited parts should included here */
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_4>---*/
/*---AUTO_GEN_PARSE<HAND_EDITED_FIELD_4_END>---*/
