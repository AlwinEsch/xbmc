from code_generator import *
from datetime import datetime

import glob
import re
import os

global header_file_copyright
header_file_copyright = """\
/*
 *  Copyright (C) 2005-""" + str(datetime.now().year) + """ Team Kodi
 *  This file is part of Kodi - https://kodi.tv
 *
 *  SPDX-License-Identifier: GPL-2.0-or-later
 *  See LICENSES/README.md for more information.
 */

/* File autogenerated, see xbmc/addons/kodi-dev-kit/tools/code-generator/code_generator.py */
"""

lowest_api = -1
highest_api = -1
known_VOID_PTR_DEFINES = [] # List created by ScanAllHdlVoidPointer
known_ENUMS = [] # List created by ScanAllEnums
known_ENUMS_DEFAULT = [] # List created by ScanAllEnums
known_C_STRUCTURES = [ ]

known_STANDARD_C_TYPES = [ 'unsigned int',
                           'signed int',
                           'int',
                           'unsigned short',
                           'signed short',
                           'short',
                           'unsigned long',
                           'signed long',
                           'long',
                           'unsigned long long',
                           'signed long long',
                           'long long',
                           'bool',
                           'float',
                           'double',
                           'long double',
                           'int64_t',
                           'int32_t',
                           'int16_t',
                           'int8_t',
                           'uint64_t',
                           'uint32_t',
                           'uint16_t',
                           'uint8_t',
                           'size_t',
                           'ssize_t',
                           'time_t' ]

known_STANDARD_C_PTR_TYPES = [ 'void*',
                               'unsigned int*',
                               'signed int*',
                               'int*',
                               'unsigned short*',
                               'signed short*',
                               'short*',
                               'unsigned long*',
                               'signed long*',
                               'long*',
                               'unsigned long long*',
                               'signed long long*',
                               'long long*',
                               'bool*',
                               'float*',
                               'double*',
                               'long double*',
                               'int64_t*',
                               'int32_t*',
                               'int16_t*',
                               'int8_t*',
                               'uint64_t*',
                               'uint32_t*',
                               'uint16_t*',
                               'uint8_t*',
                               'size_t*',
                               'ssize_t*' ]

known_STANDARD_C_TYPES_UNSIGNED = [ 'unsigned int',
                                    'unsigned short',
                                    'unsigned long',
                                    'unsigned long long',
                                    'uint64_t',
                                    'uint32_t',
                                    'uint16_t',
                                    'uint8_t',
                                    'size_t' ]

known_STANDARD_C_TYPES_SIGNED = [ 'signed int',
                                  'int',
                                  'signed short',
                                  'short',
                                  'signed long',
                                  'long',
                                  'signed long long',
                                  'long long',
                                  'int64_t',
                                  'int32_t',
                                  'int16_t',
                                  'int8_t',
                                  'ssize_t',
                                  'time_t' ]

ignored_FUNCTIONS = [ ]

def ScanAllHdlVoidPointer():
  search_dir = kodi_dir + 'xbmc/addons/kodi-dev-kit/include/kodi/c-api/'
  scan_dir = search_dir + '/**/'

  dirs = sorted(glob.glob(scan_dir, recursive=True))
  for dir in dirs:
    source_dir = dir.replace(search_dir, '')

    src_parts = sorted(glob.glob(dir + '*.h', recursive=False))
    for src_part in src_parts:
      with open(src_part) as f:
        data = f.read()
        f.close()

        for line in data.splitlines():
          m = re.search('^.*?#define\ *([a-zA-Z[0-9_]*)\ *void\*', line)
          if m and m.group(1):
            known_VOID_PTR_DEFINES.append(m.group(1))
            continue
          m = re.search('^.*typedef* void\** ([a-zA-Z[0-9_]*)\ *;$', line)
          if m and m.group(1):
            known_VOID_PTR_DEFINES.append(m.group(1))
            continue

def ScanAllEnums():
  search_dir = kodi_dir + 'xbmc/addons/kodi-dev-kit/include/kodi/c-api/'
  scan_dir = search_dir + '/**/'

  dirs = sorted(glob.glob(scan_dir, recursive=True))
  for dir in dirs:
    source_dir = dir.replace(search_dir, '')

    src_parts = sorted(glob.glob(dir + '*.h', recursive=False))
    found_one = ''
    found_use = ''
    for src_part in src_parts:
      with open(src_part) as f:
        data = f.read()
        f.close()

        for line in data.splitlines():
          if found_one:
            if '{' in line:
              found_use = found_one
              if not found_one in known_ENUMS:
                known_ENUMS.append(found_one)
            found_one = ''
            continue
          if found_use:
            if '//' in line or '/*' in line:
              continue;
            known_ENUMS_DEFAULT.append([found_use, line.strip().split(',')[0].split('=')[0].strip()])
            found_use = ''

          if not 'enum' in line:
            continue

          m = re.search('^.*?enum\ *([a-zA-Z[0-9_]*)', line)
          if m and m.group(1) and not m.group(1) in known_ENUMS:
            found_one = m.group(1)
            continue

def CheckKnownEnum(value):
  if len(value.split()) > 1:
    m = re.search('^.*?enum\ *([a-zA-Z[0-9_]*)', value)
    if m and m.group(1) and m.group(1) in known_ENUMS:
      return True
  elif value in known_ENUMS:
    return True
  return False

class GetCStruct:
  def __init__(self, name):
    self.entry = ''
    self.code = []
    self.path = ''

    name = name.replace('struct ', '')

    for entry, code, path in known_C_STRUCTURES:
      if entry == name:
        self.entry = entry
        self.code = code
        self.path = path
        return

    search_dir = kodi_dir + 'xbmc/addons/kodi-dev-kit/include/kodi/c-api/'
    scan_dir = search_dir + '/**/'

    code = []
    dirs = sorted(glob.glob(scan_dir, recursive=True))
    path = ''
    for dir in dirs:
      source_dir = dir.replace(search_dir, '')

      src_parts = sorted(glob.glob(dir + '*.h', recursive=False))
      for src_part in src_parts:
        with open(src_part) as f:
          data = f.read()
          f.close()

          found = False
          begin_found = False
          for line in data.splitlines():
            if not found and not 'struct' in line:
              continue
            code_line = line.strip()
            if not begin_found and code_line.startswith('{'):
              begin_found = True
              continue
            if code_line == '' or code_line.startswith('//') or code_line.startswith('/*'):
              continue
            if not found:
              m = re.search('^\ *(?:typedef)?\ *?struct *([a-zA-Z[0-9_]*)$', line)
              if m and m.group(1) and m.group(1) == name:
                found = True
                path = src_part
            else:
              m = re.search('^\ *}\ *(\ *[a-zA-Z[0-9_]*)\;$', line)
              if m:
                break
              code.append(code_line.split(';')[0] + ';')
      if len(code) > 0:
        known_C_STRUCTURES.append((name, code, path))
        self.entry = name
        self.code = code
        self.path = path
        break
    return

def TranslatePathToCUsableString(path, search_dir):
  return path.replace(search_dir, '').replace('.h', '_h').replace('/', '_').replace('-', '')

def FileContainsInterfaceAPICalls(file_path):
  with open(file_path) as f:
    data = f.read()
    f.close()
    for line in data.splitlines():
      if ('ATTR_APIENTRYP' in line or 'ATTR_DLL_EXPORT' in line) and not '#define' in line:
        return True

  return False

def FileContainsInterfaceAPICallsToAddon(file_path):
  with open(file_path) as f:
    data = f.read()
    f.close()
    for line in data.splitlines():
      if 'ATTR_APIENTRYP' in line and not '#define' in line and not line.strip().startswith('//'):
        return True

  return False

def IsIgnoredFunction(name):
  if name in ignored_FUNCTIONS:
    return True

  return False

def ContainsHdlVoidPointer(value):
  value = value.replace('const ', '')
  if value.split(' ', 1)[0] in known_VOID_PTR_DEFINES:
    return True
  return False

def CodeGetField_AUTO_GEN_PARSE(target_file, field_name):
  hand_edited = ''
  if os.path.exists(target_file):
    f = open(target_file, 'r')
    data = f.read()
    f.close()
    start = False
    for line in data.splitlines():
      if '/*---AUTO_GEN_PARSE<' + field_name + '>---*/' in line:
        start = True
      elif '/*---AUTO_GEN_PARSE<' + field_name + '_END>---*/' in line:
        start = False
      elif start:
        hand_edited += line + '\n'

    # Fallback for check without version
    if hand_edited == '':
      m = re.search('kodi_.*(_v[0-9]*)$', field_name)
      if m and m.group(1):
        field_name = field_name.replace(m.group(1), '')
        start = False
        for line in data.splitlines():
          if '/*---AUTO_GEN_PARSE<' + field_name + '>---*/' in line:
            start = True
          elif '/*---AUTO_GEN_PARSE<' + field_name + '_END>---*/' in line:
            start = False
          elif start:
            hand_edited += line + '\n'

  return hand_edited

def MakeSpaces(file_text):
  text = ''
  for x in range(len(file_text)+1):
    text += ' '
  return text

def FindDefaultEnumReturn(retval):
  for enum in known_ENUMS_DEFAULT:
    if retval == enum[0]:
      return enum[1]
  return ' 0'

def GetDefaultReturn(retval, function_complete, file_text, scan_file = ''):
  if retval == 'void':
    return ''
  elif 'bool' in retval:
    return ' false'
  elif '*' in retval:
    return ' nullptr'
  elif ContainsHdlVoidPointer(retval):
    return ' nullptr'
  elif 'float' in retval:
    return ' 0.0f'
  elif 'double' in retval:
    return ' 0.0'
  elif retval in known_STANDARD_C_TYPES_UNSIGNED:
    return ' 0'
  elif retval in known_STANDARD_C_TYPES_SIGNED:
    return ' -1'
  elif 'enum ' in retval:
    return ' ' + FindDefaultEnumReturn(retval.replace('enum ', ''))
  else:
    for line in file_text.splitlines():
      if retval in line:
        m = re.search('typedef .* \(\*' + retval + '\)\(.*\);', line)
        if m:
          return ' nullptr'

    print('FATAL: Can\'t get default return for:')
    print('       \'{}\''.format(function_complete))
    if scan_file:
      print('       On file {}'.format(scan_file))
    if not 'enum ' in retval and CheckKnownEnum('enum ' + retval):
      print('       You must set for enum a "C" conform value where must begin with enum ("enum {}")'.format(retval))
    else:
      print('       Detected non void return value and can\'t find a usable default about!')
    raise

def CheckCorrectFunctionValue(value):
  value_reduced = value.replace('*', '').replace('const ', '').replace('long long ', 'long ').strip()
  if '...' in value_reduced:
    return ''
  if len(value_reduced.split()) <= 1:
    return 'No value name present on "{}"'.format(value)
  if '&' in value_reduced:
    return 'C++ pointer set in C function "{}"'.format(value)

  value_reduced = value_reduced.replace('enum ', '').replace('struct ', '')
  if len(value_reduced.split()) <= 1:
    return 'No value name present on "{}"'.format(value)
  return ''

class RegexScanImport:
  def __init__(self, function, options):
    self.function = function
    self.options = options
    self.retval = ''
    self.funcname = ''
    self.values = []
    self.api_added = -1
    self.api_deprecated = -1
    self.api_removed = -1

    self.ifc_name_typdef = ''
    self.ifc_name_func = ''
    self.groupname = ''
    self.funcname_api_lib = ''

  def ScanFunction(self, file_text = ''):
    regex_code = '^typedef\ *(.*)\ ?\(\ *ATTR_APIENTRYP PFN_(.+?)\_V([0-9])\)(?=\()\((.*?)(?=\);|\) *__).+?(|(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.?(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))(?:[ \t]*));$'
    m = re.search(regex_code, self.function)
    if not m or not m.group(1) or not m.group(2) or not m.group(3) \
       and not m.group(4) and not m.group(6) and not m.group(8):
      print('ERROR: Function \'' + self.function + '\' not match wanted API!')
      return False

    self.retval = m.group(1)
    self.funcname = m.group(2).lower()
    self.api_added = int(m.group(3))
    self.api_deprecated = -1
    self.api_removed = -1
    self.values = []
    for value in m.group(4).split(', '):
      if value.strip() != '':
        self.values.append(value.strip())

    if m.group(6) and m.group(6) == 'INTRODUCED':
      self.api_added = int(m.group(7))
    elif m.group(6) and m.group(6) == 'DEPRECATED':
      self.api_deprecated = int(m.group(7))
    elif m.group(6) and m.group(6) == 'REMOVED':
      self.api_removed = int(m.group(7))
    if m.group(8) and m.group(8) == 'INTRODUCED':
      self.api_added = int(m.group(9))
    elif m.group(8) and m.group(8) == 'DEPRECATED':
      self.api_deprecated = int(m.group(9))
    elif m.group(8) and m.group(8) == 'REMOVED':
      self.api_removed = int(m.group(9))
    if m.group(10) and m.group(10) == 'INTRODUCED':
      self.api_added = int(m.group(11))
    elif m.group(10) and m.group(10) == 'DEPRECATED':
      self.api_deprecated = int(m.group(11))
    elif m.group(10) and m.group(10) == 'REMOVED':
      self.api_removed = int(m.group(11))

    self.ifc_name_typdef = 'PFN_{}_V{}'.format(m.group(2), self.api_added)
    for line in file_text.splitlines():
      m = re.search('^\ *' + self.ifc_name_typdef + '\ *([a-z0-9_].*)\;', line)
      if m and m.group(1):
        self.ifc_name_func = m.group(1)
        break

    if self.ifc_name_func != '':
      self.groupname = self.funcname.replace('_' + self.ifc_name_func, '')
    if not self.groupname:
      print('FATAL: Can\'t get groupname and function name for:')
      print('       \'{}\''.format(function))
      print('       Have you defined the use of typedef inside function structure?')
      raise NameError('Dev kit scan failure')

    self.funcname_api_lib = '{}_v{}'.format(self.funcname, self.api_added)

    return True

class RegexScanExport:
  def __init__(self, function, options):
    self.function = function
    self.options = options
    self.retval = ''
    self.funcname = ''
    self.values = []
    self.api_added = -1
    self.api_deprecated = -1
    self.api_removed = -1

  def ScanFunction(self, file_text = ''):
    regex_code = '^(?:[ \t]*)?ATTR_DLL_EXPORT[ \t]*(.*)[ \t](kodi.+?)(?=\()\((.*?)(?=\);|\). *__).+?(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.?(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))?.(?:__(DEPRECATED|INTRODUCED|REMOVED)_IN_KODI\(([0-9]+)\))(?:[ \t]*);$'
    m = re.search(regex_code, self.function)
    if not m or not m.group(1) or not m.group(2) or not m.group(3) \
       and not m.group(4) and not m.group(6) and not m.group(8):
      print('ERROR: Function \'' + self.function + '\' not match wanted API!')
      return False

    self.retval = m.group(1)
    self.funcname = m.group(2)
    self.values = []
    for value in m.group(3).split(', '):
      if value.strip() != '':
        self.values.append(value.strip())

    self.api_added = -1
    self.api_deprecated = -1
    self.api_removed = -1
    if m.group(4) and m.group(4) == 'INTRODUCED':
      self.api_added = int(m.group(5))
    elif m.group(4) and m.group(4) == 'DEPRECATED':
      self.api_deprecated = int(m.group(5))
    elif m.group(4) and m.group(4) == 'REMOVED':
      self.api_removed = int(m.group(5))
    if m.group(6) and m.group(6) == 'INTRODUCED':
      self.api_added = int(m.group(7))
    elif m.group(6) and m.group(6) == 'DEPRECATED':
      self.api_deprecated = int(m.group(7))
    elif m.group(6) and m.group(6) == 'REMOVED':
      self.api_removed = int(m.group(7))
    if m.group(8) and m.group(8) == 'INTRODUCED':
      self.api_added = int(m.group(9))
    elif m.group(8) and m.group(8) == 'DEPRECATED':
      self.api_deprecated = int(m.group(9))
    elif m.group(8) and m.group(8) == 'REMOVED':
      self.api_removed = int(m.group(9))

    return True

def GetLowestUsedAPI():
  """
  This function return the lowest used API version from Kodi dev kit.

  On first call the "kodi/c-api/version.h" becomes checked, on every next call
  the found value becomes reused.

  Returns:
    integer: The lowest API used.

  Raises:
    NameError: If something within scan goes wrong, error message comes before.

  Examples:
    >>> api = GetLowestUsedAPI()
  """
  global lowest_api
  if lowest_api > 0:
    return lowest_api

  # If not present start GetHighestUsedAPI where scan on init both
  GetHighestUsedAPI()
  return lowest_api

def GetHighestUsedAPI():
  """
  This function return the highest used API version from Kodi dev kit.

  On first call the "kodi/c-api/version.h" becomes checked, on every next call
  the found value becomes reused.

  Returns:
    integer: The highest API used.

  Raises:
    NameError: If something within scan goes wrong, error message comes before.

  Examples:
    >>> api = GetHighestUsedAPI()
  """
  global highest_api
  if highest_api > 0:
    return highest_api

  global lowest_api

  with open(kodi_dir + 'xbmc/addons/kodi-dev-kit/include/kodi/c-api/version.h', 'r') as f:
    file_text = f.read()
    f.close()

    version_list = []
    for line in file_text.splitlines():
      m = re.search('^#define\ __KODI_API_([0-9]*)__[ \t]*([0-9]*)?[ \t]*', line)
      if m and m.group(1) and m.group(2):
        if m.group(1) != m.group(2):
          print('FATAL: Inside "kodi-dev-kit/include/kodi/c-api/version.h" for API {} define set with different number {}.'.format(m.group(1), m.group(2)))
          print('       Both should equal!')
          raise NameError('Dev kit scan failure')
        if int(m.group(1)) > highest_api:
          highest_api = int(m.group(1))
          version_list.append(highest_api)
        if int(m.group(1)) < lowest_api or lowest_api < 0:
          lowest_api = int(m.group(1))

    start_api = lowest_api
    for api in version_list:
      if api != start_api:
        print('FATAL: It seems between Kodi min API {} and max API {} is API {} missing!'.format(lowest_api, highest_api, start_api))
        print('       Is "kodi-dev-kit/include/kodi/c-api/version.h" set correct?')
        raise NameError('Dev kit scan failure')
      start_api += 1

  if highest_api < 0:
    print('FATAL: Failed to get currently highest used api version!')
    print('       Is "kodi-dev-kit/include/kodi/c-api/version.h" available and set correct?')
    raise NameError('Dev kit scan failure')

  print('- Highest on scan found and used Kodi API version: {}'.format(highest_api))
  print('- Lowest on scan found and used Kodi API version:  {}'.format(lowest_api))
  return highest_api

def IsHighestUsedFunctionVersion(file_name, function, ifc_name_func, api_added):
  with open(file_name, 'r') as f:
    file_text = f.read()
    f.close()

    for line in file_text.splitlines():
      if line.strip().startswith('PFN_{}_V'.format(function.upper())):
        api_max = GetHighestUsedAPI()
        while api_max > int(api_added):
          if line.strip().startswith('PFN_{}_V{} {};'.format(function.upper(), api_max, ifc_name_func)):
            return False

          api_max -= 1

  for line in file_text.splitlines():
    if line.strip().startswith('PFN_{}_V{} {};'.format(function.upper(), int(api_added), ifc_name_func)):
      return True

  print('FATAL: Failed to find "{}"!'.format('PFN_{}_V{} {};'.format(function.upper(), int(api_added), ifc_name_func)))
  print('       Is "{}" set correct?'.format(file_name))
  raise NameError('Dev kit scan failure')

def IsLowerToUsedFunctionVersion(file_name, function, ifc_name_func, api_added):

  if api_added <= GetLowestUsedAPI():
    return False

  with open(file_name, 'r') as f:
    file_text = f.read()
    f.close()

    for line in file_text.splitlines():
      if line.strip().startswith('PFN_{}_V{} {};'.format(function.upper(), api_added, ifc_name_func)):
        return False

    return True
